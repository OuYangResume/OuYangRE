---
title: 程序员应该知道的一些东西
date: 2018-04-10 08:39:27
categories: java
tags: [技术] 

---

### 数据结构
1. 什么是队列、栈、链表
数组、链表、堆栈和队列是最基本的数据结构，队列就是一种先进先出的逻辑结构，栈是一种先进后出的逻辑结构。
<!-- more -->
2. 什么是树（平衡树,排序树,B树,B+树,R树,红黑树）、堆（大根堆、小根堆）、图（有向图、无向图、拓扑）
3. 栈通常采用的两种存储结构
链接存储：链栈带有头指针或头结点的单循环链表。
顺序存储：数组实现。
4. 两个栈实现队列，和两个队列实现栈
[链接答案](https://blog.csdn.net/zw_1510/article/details/51927554)

### 排序算法
#### 冒泡排序

冒泡排序是一种简单的排序方法，它的基本思想是：通过相邻两个元素之间比较和交换，使较大的元素逐渐从前面移向后面（升序），就像水底下的气泡一样逐渐向上冒泡，所以被称为“冒泡”排序。冒泡排序的最坏时间复杂度为O(n2)，平均时间复杂度为O(n2)。
``` java
 	/**
     * 排序算法
     * @param list
     */
    public static void  bubbleSort(int[] list){
        int temp;
        // 做多少轮排序（最多length-1轮）
        for (int i=0;i <list.length-1;i++){
            // 每一轮比较多少个
            for (int j=0;j<list.length-1-i;j++){
                if (list[j]>list[j+1]){
                    //交换
                    temp = list[j];
                    list[j] = list[j+1];
                    list [j+1]=temp;
                }
            }
        }
    }
```

#### 快速排序
快速排序的基本思想是：通过一轮排序将待排序元素分割成独立的两部分， 其中一部分的所有元素均比另一部分的所有元素小，然后分别对这两部分的元素继续进行快速排序，以此达到整个序列变成有序序列。快速排序的最坏时间复杂度为O(n2)，平均时间复杂度为O(n*log2n)   
``` java
/**
     * 快速排序算法
     */
    public static void quickSort(int[] list, int left, int right) {
        if (left < right) {
            // 分割数组，找到分割点
            int point = partition(list, left, right);

            // 递归调用，对左子数组进行快速排序
            quickSort(list, left, point - 1);
            // 递归调用，对右子数组进行快速排序
            quickSort(list, point + 1, right);
        }
    }

    /**
     * 分割数组，找到分割点
     */
    public static int partition(int[] list, int left, int right) {
        // 用数组的第一个元素作为基准数
        int first = list[left];
        while (left < right) {
            while (left < right && list[right] >= first) {
                right--;
            }
            // 交换
            swap(list, left, right);

            while (left < right && list[left] <= first) {
                left++;
            }
            // 交换
            swap(list, left, right);
        }
        // 返回分割点所在的位置
        return left;
    }

    /**
     * 交换数组中两个位置的元素
     */
    public static void swap(int[] list, int left, int right) {
        int temp;
        if (list != null && list.length > 0) {
            temp = list[left];
            list[left] = list[right];
            list[right] = temp;
        }
    }

```

