<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[VR全景功能]]></title>
    <url>%2F2019%2F08%2F20%2FVR%E5%85%A8%E6%99%AF%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[项目需要将华为全景相机拍摄出的照片展示在pc端，类似于微博常见的VR效果。实现效果的核心就是THREE.js。本文就介绍用webpack4搭建一个开发demo的环境，并简易介绍three.js. 搭建环境webpack4与es6的开发环境,也就是一些插件的配置。 创建项目npm init 生成package.json文件。 使用webpack 我们在跟目录下创建一个文件夹src来存放源文件 在创建一个文件夹build来存放编译后的文件 新建index.html文件 创建配置文件webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// webpack.config.js var path = require('path');var appPath = path.resolve(__dirname, './src/threeTwo.js');var buildPath = path.resolve(__dirname, './build');const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; entry: appPath,//整个页面的入口文件 output: &#123; path: buildPath,//打包输出的地址 filename: "bundle.js",//输出的文件名称 &#125;, module: &#123; rules: [ &#123; //url-loader的主要功能是：将源文件转换成DataUrl(声明文件mimetype的base64编码) //小于limit字节，以 base64 的方式引用，大于limit就交给file-loader处理了 //file-loader的主要功能是：把源文件迁移到指定的目录（可以简单理解为从源文件目录迁移到build目录 test: /\.(jpg|png|gif)$/, loader: 'url-loader?limit=8192&amp;name=asset/[hash:8].[name].[ext]' &#125;, ] &#125;, //以下是服务环境配置 devServer: &#123; port: 8085,//端口 host: 'localhost',//地址 inline: true,//用来支持dev-server自动刷新 open: true,//开启webpack-dev-server时自动打开页面 historyApiFallback: true, contentBase: path.resolve(__dirname),//用来指定index.html所在目录 publicPath: '/build/',//用来指定编译后的bundle.js的目录 openPage: "build/index.html",//指定打开的页面 hot: true,//热部署 &#125;, plugins: [ // new HtmlWebpackPlugin(), //热部署插件 // new webpack.HotModuleReplacementPlugin(), new HtmlWebpackPlugin(&#123; // filename:'b.html', template: "./src/index.html", chunksSortMode: 'none' &#125;) ],&#125; Three.js基础知识使用Three.js绘制一个三维效果，至少需要以下几个步骤： 创建一个容纳三维空间的场景 (Sence) 将需要绘制的元素加入到场景中，对元素的形状、材料、阴影等进行设置 给定一个观察场景的位置，以及观察角度，我们用相机对象（Camera）来控制 将绘制好的元素使用渲染器（Renderer）进行渲染，最终呈现在浏览器上 拿电影来类比的话，场景对应于整个布景空间，相机是拍摄镜头，渲染器用来把拍摄好的场景转换成胶卷。THREE.js文档 场景场景允许你设置哪些对象被three.js渲染以及渲染在哪里。在场景中放置对象、灯光和相机。很简单，直接创建一个Scene的实例即可。_scene = new Scene() 元素（包含光线）Three.js 为我们提供了非常多的Geometry，例如SphereGeometry（球体）、TetrahedronGeometry（四面体）、TorusGeometry（圆环体）等等。在Three.js中，材质（Material）决定了几何图形具体是以什么形式展现的。它包括了一个几何体如何形状以外的其他属性，例如色彩、纹理、透明度等等，Material和Geometry是相辅相成的，必须结合使用。 相机坐标系 我们可以在场景中添加一个坐标系，清楚的看到元素处于什么位置.12//坐标系插件scene.add(new THREE.AxisHelper(1000)); PerspectiveCamera（透视相机）1_camera = new PerspectiveCamera(fov, aspect, near, far); 最常用的摄像机类型，模拟人眼的视觉，近大远小（透视），如果是需要模拟现实，基本都是用这个相机。Fov表示的是视角，Fov越大，表示眼睛睁得越大，离得越远，看得更多。aspect代表水平方向和竖直方向可观测距离的比值。near、far分别对应相机可观测的最近和最远距离。 OrthographicCamera（正交投影相机）1_camera = new OrthographicCamera(left, right, top, bottom, near, far); 只有在这个矩形可视区域内才是可见的物体无论物体距离相机距离远或者近，在最终渲染的图片中物体的大小都保持不变。对于渲染2D场景或者UI元素是非常有用的。 position、lookAtposition属性指定了相机所处的位置。lookAt函数指定相机观察的方向。接收的参数都是一个类型为Vector3的对象。 渲染器Three.js也为我们提供了几种不同的渲染器，主要看WebGL渲染器(WebGLRenderer)。WebGL渲染器使用WebGL来绘制场景，其够利用GPU硬件加速从而提高渲染性能。Three.js绘制的元素添加到浏览器上，这个过程需要一个载体，这个载体就是Canvas，你可以通过_renderer.domElement获取到这个Canvas，并将它给定到真实DOM中。 123_renderer = new WebGLRenderer();_container = document.getElementById('conianer');_container.appendChild(_renderer.domElement); 使用setSize函数设定你要渲染的范围，实际上它改变的就是上面Canvas的范围.通过render函数渲染上面指定的场景和相机. 12_renderer.setSize(window.innerWidth, window.innerHeight);_renderer.render(_scene, _camera); requestAnimationFrame要渲染的元素可能并未被加载完，你就执行了渲染，并且只执行了一次，这时需要requestAnimationFrame方法，让场景和相机进行实时渲染。 1234function animate() &#123; requestAnimationFrame(animate); _renderer.render(_scene, _camera); &#125; 全景效果基本逻辑 将一张全景图包裹在球体的内壁. 设定一个观察点，在球的圆心. 使用鼠标可以拖动球体，从而改变我们看到全景的视野. 鼠标滚轮可以缩放，和放大，改变观察全景的远近. 初始化把必要的基础设施搭建起来，场景、相机（选择远景相机，这样可以让全景看起来更真实）、渲染器：按照three.js官网搭建最基础的即可。 1234567891011121314151617181920212223242526272829303132333435363738394041import * as THREE from &apos;three&apos;;init();function init() &#123; //创建一个场景 var _scene = new THREE.Scene(); //创建一个相机，视角，长宽比，近远裁剪面 var _camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); _camera.position.set(0, 300, 600); _camera.lookAt(new THREE.Vector3(0, 0, 0)) //渲染器 var renderer = new THREE.WebGLRenderer(); let _container = document.getElementById(&apos;conianer&apos;); renderer.setSize(window.innerWidth, window.innerHeight); _container.appendChild(renderer.domElement); //创建一个长方体 var geometry = new THREE.BoxGeometry(200, 100, 100); var material = new THREE.MeshStandardMaterial(&#123; color: 0x00ff00 &#125;); var mesh = new THREE.Mesh(geometry, material); _scene.add(mesh); // 创建平行光-照亮几何体 var directionalLight = new THREE.DirectionalLight(0xffffff, 1); directionalLight.position.set(-4, 8, 12); _scene.add(directionalLight); // 创建环境光 var ambientLight = new THREE.AmbientLight(0xffffff); _scene.add(ambientLight); var animate = function () &#123; requestAnimationFrame(animate); mesh.rotation.x += 0.01; mesh.rotation.y += 0.01; renderer.render(_scene, _camera); &#125;; animate();&#125; 在场景内添加一个球体，并把全景图作为材料包裹在球体上面并将相机的中心点移动到球的中心. 12345678910function addImg(url) &#123; const texture = THREE.ImageUtils.loadTexture(url); const material = new THREE.MeshBasicMaterial(&#123; map: texture &#125;); const geometry = new THREE.SphereGeometry(10, 256, 256); // const geometry = new THREE.SphereGeometry(50, 256, 256); const mesh = new THREE.Mesh(geometry, material); // 渲染球体的双面 material.side = THREE.DoubleSide; return mesh;&#125; 插件添加事件全景图已经可以浏览了，但是你只能看到一部分，并不能拖动它看到其他部分，为了精确的控制拖动的速度和缩放、放大等场景，用到的是three.js作者提供的插件OrbitControls。其实里面的原理也就是给_renderer.domElement上面提到的canvas增加一些监听鼠标事件。下面就是使用的完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import * as THREE from &apos;three&apos;//OrbitControls不是核心的一部分。您必须将类转换为模块并单独导入它。import &#123; OrbitControls &#125; from &apos;three/examples/jsm/controls/OrbitControls&apos;;//const OrbitControls= require(&quot;./lib/OrbitControls&quot;)function init() &#123; const renderer = new THREE.WebGLRenderer(); renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(window.innerWidth, window.innerHeight); let _container = document.getElementById(&apos;conianer&apos;); // stat = new Stats(); // document.body.appendChild(stat.dom); //一个canvas，渲染器在其上绘制输出。 _container.appendChild(renderer.domElement); const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 0.1, 100 ); camera.position.set(20, 0, 0); // camera.position.set(-0.3, 0, 0); const controls = new OrbitControls(camera, renderer.domElement); //添加视图改变的回调函数。 controls.addEventListener(&quot;change&quot;, render); controls.minDistance = 1; // controls.maxDistance = 200; controls.maxDistance = 20; controls.enablePan = false; // const geometry = new THREE.SphereGeometry(1, 10, 10); // const material = new THREE.MeshBasicMaterial(&#123; color: 0xff0000 &#125;); // const mesh = new THREE.Mesh(geometry, material); const mesh = addImg(&quot;../img/p4.jpg&quot;); // const mesh = addImg(&quot;https://qhyxpicoss.kujiale.com/r/2019/07/01/L3D137S8ENDIADDWAYUI5L7GLUF3P3WS888_3000x4000.jpg?x-oss-process=image/resize,m_fill,w_1600,h_920/format,webp&quot;, scene, 1); scene.add(mesh); controls.update(); controls.target.copy(mesh.position); function render() &#123; renderer.render(scene, camera); &#125; function r() &#123; render(); requestAnimationFrame(r) &#125; //坐标插件 scene.add(new THREE.AxisHelper(1000)); r()&#125;function addImg(url) &#123; const texture = THREE.ImageUtils.loadTexture(url); const material = new THREE.MeshBasicMaterial(&#123; map: texture &#125;); const geometry = new THREE.SphereGeometry(10, 256, 256); // const geometry = new THREE.SphereGeometry(50, 256, 256); const mesh = new THREE.Mesh(geometry, material); // 渲染球体的双面 material.side = THREE.DoubleSide; return mesh;&#125;init(); 您的浏览器不支持Video标签。 自己添加事件博文太长不好看就只添加一个放大缩小的功能（写的太丑,相对简单）。 123456789_renderer.domElement.addEventListener('wheel', function (e) &#123; //deltaY 的值大于1时，竖直方向的 DOMMouseScroll 事件,视野放大。 var delta = e.deltaY &gt; 0 ? 15 : -15; if (_camera.fov + delta * 0.05 &gt;= 1 &amp;&amp; _camera.fov + delta * 0.05 &lt;= 100) &#123; _camera.fov += delta * 0.05; //更新摄像机投影矩阵。在任何参数被改变以后必须被调用。 _camera.updateProjectionMatrix(); &#125; &#125;, false); 视图移动代码部分在我github上源码地址。 后续 添加标记功能。 封装成插件，方便使用。 实现类似这种功能中国馆]]></content>
      <categories>
        <category>Three.js</category>
      </categories>
      <tags>
        <tag>Three.js</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker部署web项目]]></title>
    <url>%2F2019%2F06%2F27%2FDocker%E9%83%A8%E7%BD%B2web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[本文使用Docker来部署一个vue的前端应用,后台是express提供的接口。更多的实践docker命令,上篇文章有关于Docker更详细的介绍. 部署node服务运行本地express这个后台服务就用很早之前写的项目,项目地址在github上。运行该 express 应用需要 node 环境，我们基于 node 镜像来构建一个新镜像. 拉取node镜像docker pull nodedocker 镜像名称由REPOSITORY和TAG组成 [REPOSITORY[:TAG]]，TAG默认为latest。查看所有镜像docker image ls 编写Dockerfile文件在express项目的根目录创建Dockerfile文件。 1234567891011121314#基于 node:latest 镜像而构建的FROM node#指定工作目录WORKDIR /usr/src/app#COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。COPY package*.json ./#安装依赖RUN npm install#将所有文件copy到工作目录COPY . .#声明运行时容器提供服务端口EXPOSE 8082#指定默认的容器主进程的启动命令CMD [ "npm", "start" ] 这里的端口是指容器端口-p &lt;宿主端口&gt;:&lt;容器端口&gt;跟运行并没有关系。 构建镜像docker build -t nodeWebServer .-t 是给镜像命名 . 是基于当前目录的Dockerfile来构建镜像 启动容器基于该镜像启动一个docker容器。 1234docker run \-p 8088:8082 \-d --name nodeApp \nodeWebServer docker run 基于镜像启动一个容器 -p 8088:8082 端口映射，将宿主的8088端口映射到容器的8082端口 -d 后台方式运行 --name 容器名 查看 docker 进程docker container ls -a进入这个已经启动的容器docker exec -it containerID bash 可以看到Dockerfile指定的工作目录和copy过来的文件。 访问http://localhost:8088 部署前端应用vue项目将前端项目运行起来并打包npm run build现在将这个生成的dist静态文件部署到docker上。 拉取nginx镜像docker pull nginx这次就基于nginx这个基础镜像部署项目（node项目是新建了一个镜像）。 创建nginx config配置文件在项目根目录下创建nginx文件夹，该文件夹下新建文件default.conf 12345678910111213141516171819202122232425262728server &#123; listen 80; server_name localhost; #charset koi8-r; access_log /var/log/nginx/host.access.log main; error_log /var/log/nginx/error.log error; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; location /api/ &#123; rewrite /api/(.*) /$1 break; proxy_pass http://172.17.0.4:8082; &#125;&#125; 这个文件可以看到首页的指向为 /usr/share/nginx/html/index.html, 所以我们可以一会把构建出来的index.html文件和相关的静态资源放到/usr/share/nginx/html目录下。还将上面node服务代理出去了。容器内部 ip 通过查看docker inspect containerID 启动容器123456docker run \-p 8000:80 \-d --name vuenginx \--mount type=bind,source=$HOME/vueclidemo/nginx,target=/etc/nginx/conf.d \--mount type=bind,source=$HOME/vueclidemo/dist,target=/usr/share/nginx/html \nginx 12$HOME是指项目所在系统盘位置--mount type=bind,source=&#123;sourceDir&#125;,target=&#123;targetDir&#125; 将宿主机的sourceDir 挂载到容器的 targetDir 目录上。 访问localhost:8000/api/*就可以请求到node的后台服务了。 编写sheel脚本每次启动容器运行的命令较长，如果每次重新输入难免麻烦，我们可以将完整的命令保存到一个shell文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#!/bin/sh:&lt;&lt;EOF docker 运行脚本 shell author:oouyangEOF# `解释器 !# 而不用在终端之前输入sh, bash.`#!/bin/sh##### 查看所有镜像 docker image ls##### 查看所有容器 docker container ls -a##### 启动已终止容器 docker container start containerID#### 查看单个容器信息 docker inspect containerID##### 进入容器 docker exec -it containerID bashHOME=/Users/oouyang/Desktop/github/nodeecho "输入1查看所有镜像"echo "输入2 运行nginx"echo "输入3 查看所有容器并选择删除"echo "输入4 删除镜像"echo "输入5 查看容器信息"read -p $'\n\n请选择你要的操作:' aNumcase $aNum in 1) echo '所有镜像' docker image ls ;; 2) echo '查看所有容器' docker container ls -a read -p $'\n\n请输入您要运行的镜像：' imageName if [[ $imageName = 'nginx' || $imageName = 'vuenginxcontainer' ]] then read -p $'\n\n请输入映射端口：' -n 6 -t 5 -s ipCode #-p 输入提示文字 #-n 输入字符长度限制(达到6位，自动结束) #-t 输入限时 #-s 隐藏输入内容 docker run -p $ipCode:80 -d \ --mount type=bind,source=$HOME/vueclidemo/nginx,target=/etc/nginx/conf.d \ --mount type=bind,source=$HOME/vueclidemo/dist,target=/usr/share/nginx/html \ $imageName echo -e "\n请访问localhost:$ipCode" #echo 后面是双引号 fi ;; 3) echo '查看所有容器' docker container ls -a read -p $'\n\n请输入您要删除的容器：' containerName docker container stop $containerName docker container rm $containerName echo "\n删除 $containerName容器成功！" ;; 4) echo '查看所有镜像' docker image ls read -p $'\n\n请输入您要删除的镜像:' imageName docker image rm $imageName ;; 5) echo '查看所有容器信息' docker container ls -a read -p $'\n\n请输入您要查看的容器名称:' containerName1 docker inspect $containerName1 ;; *) echo '你没有输入 1 到 5 之间的数字' ;;esac]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nginx</tag>
        <tag>Vue</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Base]]></title>
    <url>%2F2019%2F06%2F24%2FDocker-Base%2F</url>
    <content type="text"><![CDATA[前言此文章是公司同事docker培训时准备的资料，也来自于网络。如有侵权，联系必删。 什么是 DockerDocker 是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的维护效率，降低了云计算应用开发的成本！使用 Docker，可以让应用的部署、测试和分发都变得前所未有的高效和轻松！ 无论是应用开发者、运维人员、还是其他信息技术从业人员，都有必要认识和掌握 Docker，节约有限的生命。 本教程适用于具备基础 Linux 知识的 Docker 初学者。 Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。 Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 为什么要使用 Docker？作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。 更高效的利用系统资源由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。 更快速的启动时间传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。 一致的运行环境开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。 持续交付和部署对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。 使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。 而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。 更轻松的迁移由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。 更轻松的维护和扩展Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。 对比传统虚拟机总结 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为 MB 一般为 GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 基本概念Docker 包括三个基本概念 镜像（Image） 容器（Container） 仓库（Repository） 理解了这三个概念，就理解了 Docker 的整个生命周期。 Docker 镜像我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。 Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 分层存储因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。 镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。 分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。 Docker 容器镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。 前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。 按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。 Docker Registry镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。 一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。 通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 ubuntu:14.04，或者 ubuntu:18.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。 仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。 Docker Registry 公开服务Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。 最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 CoreOS 的 Quay.io，CoreOS 相关的镜像存储在这里；Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务。 由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 安装 Docker 一节中有详细的配置方法。 国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 时速云镜像仓库、网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库 等。 私有 Docker Registry除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry镜像，可以直接使用做为私有 Registry 服务。在 私有仓库 一节中，会有进一步的搭建私有 Registry 服务的讲解。 开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 Docker Trusted Registry 中，提供了这些高级功能。 除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，VMWare Harbor 和 Sonatype Nexus。 安装 DockerDocker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。 Docker 社区版 (CE) 是开发人员和小型团队开始使用 Docker 并尝试使用基于容器的应用的理想之选。Docker CE 有两个更新渠道，即 stable 和 edge： Stable 每个季度为您提供可靠更新 Edge 每个月为您提供新功能 从 Docker 17.03 开始，Docker 使用基于时间的发行计划。 官方网站上有各种环境下的 安装指南，这里主要介绍 Docker CE 在 Linux 的安装。 CentOS 安装 Docker CE 警告：切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker. 准备工作系统要求Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。 卸载旧版本旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本： 12345678910$ sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine 使用 yum 安装执行以下命令安装依赖包： 123$ sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 安装 yum-utils，它提供一个 yum-config-manager 单元，同时安装的 device-mapper-persistent-data 和 lvm2 用于储存设备映射（devicemapper）必须的两个软件包。 鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。 执行下面的命令添加 yum 软件源： 仓库配置会保存到 /etc/yum.repos.d/docker-ce.repo 文件中。 123456789$ sudo yum-config-manager \ --add-repo \ https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo# 官方源# $ sudo yum-config-manager \# --add-repo \# https://download.docker.com/linux/centos/docker-ce.repo 安装 Docker CE更新 yum 软件源缓存，并安装 docker-ce。 12$ sudo yum makecache fast$ sudo yum install docker-ce 使用脚本自动安装在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装： 12$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun 执行这个命令，脚本就会自动的将一切准备工作做好，并把 Docker CE 的 Edge 版本安装在系统中。 由于网络原因，在国内这个脚本可能会出现下载错误的情况。国内一些云服务商提供了这个脚本的修改版本，使用国内的 Docker 软件源镜像安装。如DaoCloud 的安装脚本。 1curl -sSL https://get.daocloud.io/docker | sh 查看 Docker 版本12345678910111213141516171819[root@skyline Null]# docker versionClient: Version: 18.09.5 API version: 1.39 Go version: go1.10.8 Git commit: e8ff056 Built: Thu Apr 11 04:43:34 2019 OS/Arch: linux/amd64 Experimental: falseServer: Docker Engine - Community Engine: Version: 18.09.5 API version: 1.39 (minimum version 1.12) Go version: go1.10.8 Git commit: e8ff056 Built: Thu Apr 11 04:13:40 2019 OS/Arch: linux/amd64 Experimental: false 启动 Docker CE设置随系统启动 1$ sudo systemctl enable docker 启动 Docker 1$ sudo systemctl start docker 建立 docker 用户组默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 建立 docker 组： 1$ sudo groupadd docker 将当前用户加入 docker 组： 1$ sudo usermod -aG docker $USER 退出当前终端并重新登录，进行如下测试。 测试 Docker 是否安装正确123456789101112131415161718192021222324252627[root@skyline Null]# docker run hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-world1b930d010525: Pull complete Digest: sha256:2557e3c07ed1e38f26e389462d03ed943586f744621577a99efb77324b0fe535Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the "hello-world" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 若能正常输出以上信息，则说明安装成功。 镜像加速器国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如： Docker 官方提供的中国 registry mirror https://registry.docker-cn.com 阿里云加速器(需登录账号获取) 道客 DaoCloud 镜像站 当配置某一个加速器地址之后，若发现拉取不到镜像，请切换到另一个加速器地址。 国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务。 我们以 Docker 官方加速器 https://registry.docker-cn.com 为例进行介绍。 CentOS 7对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件） 12345&#123; "registry-mirrors": [ "https://registry.docker-cn.com" ]&#125; 注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。 之后重新启动服务。 12$ sudo systemctl daemon-reload$ sudo systemctl restart docker 检查加速器是否生效命令行执行 docker info，如果从结果中看到了如下内容，说明配置成功。 12Registry Mirrors: https://registry.docker-cn.com/ 使用 Docker 镜像在之前的介绍中，我们知道镜像是 Docker 的三大组件之一。 Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。 获取镜像之前提到过，Docker Hub 上有大量的高质量的镜像可以用。 从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为： 1docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 具体的选项可以通过 docker pull --help 命令看到，这里我们说一下镜像名称的格式。 Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。 仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。 比如： 1234567[Null@skyline ~]$ docker pull nginx:1.14.01.14.0: Pulling from library/nginxf17d81b4b692: Pull complete 3df1ab0a1750: Pull complete 576b56a453df: Pull complete Digest: sha256:8b600a4d029481cc5b459f1380b30ff6cb98e27544fc02370de836e397e34030Status: Downloaded newer image for nginx:1.14.0 上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 nginx:1.14.0，因此将会获取官方镜像 library/nginx 仓库中标签为 1.14.0 的镜像。 从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。 运行有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 centos:7 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。 12345678$ docker run -it --rm \ centos:7 \ bash[root@a69cb7d46e0c /]# cat /etc/centos-releaseCentOS Linux release 7.6.1810 (Core)[root@a69cb7d46e0c /]# uname -aLinux a69cb7d46e0c 3.10.0-957.el7.x86_64 #1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux docker run 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。 -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 --rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。 centos:7：这是指用 centos:7 镜像为基础来启动容器。 bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。 进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/centos-release，这是 CentOS 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 CentOS Linux release 7.6 系统。 最后我们通过 exit 退出了这个容器。 列出镜像要想列出已经下载下来的镜像，可以使用 docker image ls 命令。 12345[Null@skyline ~]$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEcentos 7 9f38484d220f 3 weeks ago 202MBhello-world latest fce289e99eb9 3 months ago 1.84kBnginx 1.14.0 ecc98fc2f376 5 months ago 109MB 列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。 其中仓库名、标签在之前的基础概念章节已经介绍过了。镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个标签。 镜像体积如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 docker image ls 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。 另外一个需要注意的问题是，docker image ls 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。 你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。 123456[Null@skyline ~]$ docker system dfTYPE TOTAL ACTIVE SIZE RECLAIMABLEImages 3 0 310.7MB 310.7MB (100%)Containers 0 0 0B 0BLocal Volumes 0 0 0B 0BBuild Cache 0 0 0B 0B 虚悬镜像镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 &lt;none&gt;。 1&lt;none&gt; &lt;none&gt; 00285df0df87 5 days ago 342 MB 这个镜像原本是有镜像名和标签的，原来为 mongo:3.2，随着官方镜像维护，发布了新版本后，重新 docker pull mongo:3.2 时，mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 &lt;none&gt;。除了 docker pull 可能导致这种情况，docker build 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 &lt;none&gt; 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像： 123$ docker image ls -f dangling=trueREPOSITORY TAG IMAGE ID CREATED SIZE&lt;none&gt; &lt;none&gt; 00285df0df87 5 days ago 342 MB 一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。 1234[Null@skyline ~]$ docker image pruneWARNING! This will remove all dangling images.Are you sure you want to continue? [y/N] yTotal reclaimed space: 0B 中间层镜像为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。 1$ docker image ls -a 这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。 列出部分镜像不加任何参数的情况下，docker image ls 会列出所有顶级镜像，但是有时候我们只希望列出部分镜像。docker image ls 有好几个参数可以帮助做到这个事情。 根据仓库名列出镜像 1234$ docker image ls ubuntuREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 18.04 f753707788c5 4 weeks ago 127 MBubuntu latest f753707788c5 4 weeks ago 127 MB 列出特定的某个镜像，也就是说指定仓库名和标签 123$ docker image ls ubuntu:18.04REPOSITORY TAG IMAGE ID CREATED SIZEubuntu 18.04 f753707788c5 4 weeks ago 127 MB 除此以外，docker image ls 还支持强大的过滤器参数 --filter，或者简写 -f。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 mongo:3.2 之后建立的镜像，可以用下面的命令： 1234$ docker image ls -f since=mongo:3.2REPOSITORY TAG IMAGE ID CREATED SIZEredis latest 5f515359c7f8 5 days ago 183 MBnginx latest 05a60462f8ba 5 days ago 181 MB 想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。 此外，如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。 12$ docker image ls -f label=com.example.version=0.1... 以特定格式显示默认情况下，docker image ls 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 docker image ls 把所有的虚悬镜像的 ID 列出来，然后才可以交给 docker image rm 命令作为参数来删除指定的这些镜像，这个时候就用到了 -q 参数。 12345678$ docker image ls -q5f515359c7f805a60462f8bafe9198c04d6200285df0df87f753707788c5f753707788c51e0c3dd64ccd --filter 配合 -q 产生出指定范围的 ID 列表，然后送给另一个 docker 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。 另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 Go 的模板语法。 比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名： 12345678$ docker image ls --format "&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"5f515359c7f8: redis05a60462f8ba: nginxfe9198c04d62: mongo00285df0df87: &lt;none&gt;f753707788c5: ubuntuf753707788c5: ubuntu1e0c3dd64ccd: ubuntu 或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列： 12345678$ docker image ls --format "table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"IMAGE ID REPOSITORY TAG5f515359c7f8 redis latest05a60462f8ba nginx latestfe9198c04d62 mongo 3.200285df0df87 &lt;none&gt; &lt;none&gt;f753707788c5 ubuntu 18.04f753707788c5 ubuntu latest 删除本地镜像如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为： 1$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] 用 ID、镜像名、摘要删除镜像其中，&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。 比如我们有这么一些镜像： 123456$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 0584b3d2cf6d 3 weeks ago 196.5 MBredis alpine 501ad78535f0 3 weeks ago 21.03 MBdocker latest cf693ec9b5c7 3 weeks ago 105.1 MBnginx latest e43d811ce2f4 5 weeks ago 181.5 MB 我们可以用镜像的完整 ID，也称为 长 ID，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 短 ID 来删除镜像。docker image ls 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。 比如这里，如果我们要删除 redis:alpine 镜像，可以执行： 123456789$ docker image rm 501Untagged: redis:alpineUntagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86dDeleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899bDeleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2faDeleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7 我们也可以用镜像名，也就是 &lt;仓库名&gt;:&lt;标签&gt;，来删除镜像。 12345$ docker image rm centosUntagged: centos:latestUntagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366cDeleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8aDeleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38 Untagged 和 Deleted如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 Untagged，另一类是 Deleted。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。 因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 Untagged 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 Delete 行为就不会发生。所以并非所有的 docker image rm 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。 当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变动非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 docker pull 看到的层数不一样的源。 除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。 用 docker image ls 命令来配合像其它可以承接多个实体的命令一样，可以使用 docker image ls -q 来配合使用 docker image rm，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。 比如，我们需要删除所有仓库名为 redis 的镜像： 1$ docker image rm $(docker image ls -q redis) 或者删除所有在 mongo:3.2 之前的镜像： 1$ docker image rm $(docker image ls -q -f before=mongo:3.2) 充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。 利用 commit 理解镜像构成注意： docker commit 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 docker commit 定制镜像，定制镜像应该使用 Dockerfile 来完成。 镜像是容器的基础，每次执行 docker run 的时候都会指定哪个镜像作为容器运行的基础。在之前的例子中，我们所使用的都是来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求，而当这些镜像无法直接满足需求时，我们就需要定制这些镜像。 回顾一下之前我们学到的知识，镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。 现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。 1$ docker run --name webserver -d -p 80:80 nginx 这条命令会用 nginx 镜像启动一个容器，命名为 webserver，并且映射了 80 端口，这样我们可以用浏览器或curl命令去访问这个 nginx 服务器。我们会看到默认的 Nginx 欢迎页面。 1234567891011121314151617181920212223242526[Null@skyline ~]$ curl http://127.0.0.1&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html 现在，假设我们不喜欢这个欢迎页面，我们改成欢迎 Docker 的文字，我们可以使用 docker exec命令进入容器，修改其内容。重新访问后就能看到内容被改变了。 123456[Null@skyline ~]$ docker exec -it webserver bashroot@bc54bf48628a:/# echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html root@bc54bf48628a:/# exitexit[Null@skyline ~]$ curl http://127.0.0.1&lt;h1&gt;Hello, Docker!&lt;/h1&gt; 我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 docker diff 命令看到具体的改动。 123456789101112131415161718[Null@skyline ~]$ docker diff webserverC /varC /var/cacheC /var/cache/nginxA /var/cache/nginx/fastcgi_tempA /var/cache/nginx/proxy_tempA /var/cache/nginx/scgi_tempA /var/cache/nginx/uwsgi_tempA /var/cache/nginx/client_tempC /runA /run/nginx.pidC /usrC /usr/shareC /usr/share/nginxC /usr/share/nginx/htmlC /usr/share/nginx/html/index.htmlC /rootA /root/.bash_history 现在我们定制好了变化，我们希望能将其保存下来形成镜像。 要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。 docker commit 的语法格式为： 1docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]] 我们可以用下面的命令将容器保存为镜像： 123456[Null@skyline ~]$ docker commit \ --author "Null &lt;test@skyline.name&gt;" \ --message "update" \ webserver \ nginx:v2sha256:de0d79c679fd4c7b17d25cb502f48443b92066186b0ea305a401242e15b62a80 其中 --author 是指定修改的作者，而 --message 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空。 我们可以在 docker images 中看到这个新定制的镜像： 1234567[Null@skyline ~]$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx v2 de0d79c679fd 19 seconds ago 109MBnginx latest bb776ce48575 5 days ago 109MBcentos 7 9f38484d220f 4 weeks ago 202MBhello-world latest fce289e99eb9 3 months ago 1.84kBnginx 1.14.0 ecc98fc2f376 6 months ago 109MB 我们还可以用 docker history 具体查看镜像内的历史记录，如果比较 nginx:latest 的历史记录，我们会发现新增了我们刚刚提交的这一层。 12345678910111213[Null@skyline ~]$ docker history nginx:v2IMAGE CREATED CREATED BY SIZE COMMENTde0d79c679fd 2 minutes ago nginx -g daemon off; 98B updatebb776ce48575 5 days ago /bin/sh -c #(nop) CMD … 0B &lt;missing&gt; 5 days ago /bin/sh -c #(nop) STOP… 0B &lt;missing&gt; 5 days ago /bin/sh -c #(nop) EXPO… 0B &lt;missing&gt; 5 days ago /bin/sh -c ln -sf /dev/… 22B &lt;missing&gt; 5 days ago /bin/sh -c set -x &amp;&amp; a… 54MB &lt;missing&gt; 5 days ago /bin/sh -c #(nop) ENV … 0B &lt;missing&gt; 5 days ago /bin/sh -c #(nop) ENV … 0B &lt;missing&gt; 2 weeks ago /bin/sh -c #(nop) LABE… 0B &lt;missing&gt; 2 weeks ago /bin/sh -c #(nop) CMD … 0B &lt;missing&gt; 2 weeks ago /bin/sh -c #(nop) ADD f… 55.3MB 新的镜像定制好后，我们可以来运行这个镜像。并访问容器。 1234[Null@skyline ~]$ docker run --name web2 -d -p 81:80 nginx:v2e7666e6d3677274727f2d4a53faf8567fc4def19fcfff17d5081d33fe1e95e71[Null@skyline ~]$ curl http://127.0.0.1:81&lt;h1&gt;Hello, Docker!&lt;/h1&gt; 这里我们命名为新的服务为 web2，并且映射到 81 端口。其内容应该和之前修改后的 webserver 一样。 慎用 docker commit使用 docker commit 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。 首先，如果仔细观察之前的 docker diff webserver 的结果，你会发现除了真正想要修改的 /usr/share/nginx/html/index.html 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。 此外，使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 docker diff 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。 而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 docker commit 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。 使用 Dockerfile 定制镜像从刚才的 docker commit 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。 Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。 在一个空白目录中，建立一个文本文件，并命名为 Dockerfile： 123[Null@skyline ~]$ mkdir nginx-v3[Null@skyline ~]$ cd nginx-v3/[Null@skyline nginx-v3]$ touch Dockerfile 其内容为： 12FROM nginxRUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html 这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。 FROM 指定基础镜像所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 在 Docker Hub 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。 如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。 除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。 12FROM scratch... 如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。 不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 swarm、coreos/etcd。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。 RUN 执行命令RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种： shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。 1RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html exec 格式：RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]，这更像是函数调用中的格式。 既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样： 123456789FROM debian:stretchRUN apt-get updateRUN apt-get install -y gcc libc6-dev make wgetRUN wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz"RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install 之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。 而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。 Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。 上面的 Dockerfile 正确的写法应该是这样： 1234567891011121314FROM debian:stretchRUN buildDeps='gcc libc6-dev make wget' \ &amp;&amp; apt-get update \ &amp;&amp; apt-get install -y $buildDeps \ &amp;&amp; wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \ &amp;&amp; mkdir -p /usr/src/redis \ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \ &amp;&amp; make -C /usr/src/redis \ &amp;&amp; make -C /usr/src/redis install \ &amp;&amp; rm -rf /var/lib/apt/lists/* \ &amp;&amp; rm redis.tar.gz \ &amp;&amp; rm -r /usr/src/redis \ &amp;&amp; apt-get purge -y --auto-remove $buildDeps 首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。 并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。 此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。 很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。 构建镜像好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。 在 Dockerfile 文件所在目录执行： 12345678910[Null@skyline nginx-v3]$ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048kBStep 1/2 : FROM nginx ---&gt; bb776ce48575Step 2/2 : RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html ---&gt; Running in a507cc636c47Removing intermediate container a507cc636c47 ---&gt; 209117ed7ac3Successfully built 209117ed7ac3Successfully tagged nginx:v3 从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，如同我们之前所说的那样，RUN 指令启动了一个容器 a507cc636c47，执行了所要求的命令，并最后提交了这一层 209117ed7ac3，随后删除了所用到的这个容器 a507cc636c47。 这里我们使用了 docker build 命令进行镜像构建。其格式为： 1docker build [选项] &lt;上下文路径/URL/-&gt; 在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。 镜像构建上下文（Context）如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什么是上下文呢？ 首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。 当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？ 这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。 如果在 Dockerfile 中这么写： 1COPY ./package.json /app/ 这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。 因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。 现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。 如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程： 123[Null@skyline nginx-v3]$ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048kB... 理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。 一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。 那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。 这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。 当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。 其它 docker build 的用法直接用 Git repo 进行构建或许你已经注意到了，docker build 还支持从 URL 构建，比如可以直接从 Git repo 中构建： 12345678$ docker build https://github.com/twang2218/gitlab-ce-zh.git#:11.1Sending build context to Docker daemon 2.048 kBStep 1 : FROM gitlab/gitlab-ce:11.1.0-ce.011.1.0-ce.0: Pulling from gitlab/gitlab-ceaed15891ba52: Already exists773ae8583d14: Already exists... 这行命令指定了构建所需的 Git repo，并且指定默认的 master 分支，构建目录为 /11.1/，然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。 用给定的 tar 压缩包构建1$ docker build http://server/context.tar.gz 如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。 从标准输入中读取 Dockerfile 进行构建1docker build - &lt; Dockerfile 或 1cat Dockerfile | docker build - 如果标准输入传入的是文本文件，则将其视为 Dockerfile，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 COPY 进镜像之类的事情。 从标准输入中读取上下文压缩包进行构建1$ docker build - &lt; context.tar.gz 如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。 Dockerfile 指令详解我们已经介绍了 FROM，RUN，还提及了 COPY, ADD，其实 Dockerfile 功能很强大，它提供了十多个指令。下面我们继续讲解其他的指令。 COPY 复制文件格式： COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt; COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;] 和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。 COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如： 1COPY package.json /usr/src/app/ &lt;源路径&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如： 12COPY hom* /mydir/COPY hom?.txt /mydir/ &lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。 在使用该指令的时候还可以加上 --chown=&lt;user&gt;:&lt;group&gt; 选项来改变文件的所属用户及所属组。 1234COPY --chown=55:mygroup files* /mydir/COPY --chown=bin files* /mydir/COPY --chown=1 files* /mydir/COPY --chown=10:11 files* /mydir/ ADD 更高级的复制文件ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。 比如 &lt;源路径&gt; 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。 如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。 在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 ubuntu 中： 123FROM scratchADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /... 但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令了。 在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。 另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。 因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。 在使用该指令的时候还可以加上 --chown=&lt;user&gt;:&lt;group&gt; 选项来改变文件的所属用户及所属组。 1234ADD --chown=55:mygroup files* /mydir/ADD --chown=bin files* /mydir/ADD --chown=1 files* /mydir/ADD --chown=10:11 files* /mydir/ CMD 容器启动命令CMD 指令的格式和 RUN 相似，也是两种格式： shell 格式：CMD &lt;命令&gt; exec 格式：CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...] 参数列表格式：CMD [&quot;参数1&quot;, &quot;参数2&quot;...]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。 之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。 在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。 在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 &quot;，而不要使用单引号。 如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如： 1CMD echo $HOME 在实际执行中，会将其变更为： 1CMD [ "sh", "-c", "echo $HOME" ] 这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。 提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。 Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。 一些初学者将 CMD 写为： 1CMD service nginx start 然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。 对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。 而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而刚才说了 CMD service nginx start 会被理解为 CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。 正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如： 1CMD ["nginx", "-g", "daemon off;"] ENTRYPOINT 入口点ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。 ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 --entrypoint 来指定。 当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为： 1&lt;ENTRYPOINT&gt; "&lt;CMD&gt;" 那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种 &lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot; 有什么好处么？让我们来看几个场景。 场景一：让镜像变成像命令一样使用假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现： 12FROM centos:7CMD [ "curl", "-s", "https://pv.sohu.com/cityjson" ] 假如我们使用 docker build -t myip . 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行： 12[Null@skyline docker]$ docker run myipvar returnCitySN = &#123;"cip": "120.229.5.147", "cid": "CN", "cname": "CHINA"&#125;; 嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 CMD 中可以看到实质的命令是 curl，那么如果我们希望显示 HTTP 头信息，就需要加上 -i 参数。那么我们可以直接加 -i 参数给 docker run myip 么？ 12[Null@skyline docker]$ docker run myip -idocker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused "exec: \"-i\": executable file not found in $PATH": unknown. 我们可以看到可执行文件找不到的报错，executable file not found。之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s https://ip.cn 后面。而 -i 根本不是命令，所以自然找不到。 那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令： 1$ docker run myip curl -s https://pv.sohu.com/cityjson -i 这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用 ENTRYPOINT 来实现这个镜像： 12FROM centos:7ENTRYPOINT [ "curl", "-s", "https://pv.sohu.com/cityjson" ] 这次我们再来尝试直接使用 docker run myip -i： 12345678910111213$ docker run myipvar returnCitySN = &#123;"cip": "120.229.5.147", "cid": "CN", "cname": "CHINA"&#125;;$ docker run myip -iHTTP/1.1 200 OKContent-Type: text/json; charset=gbkContent-Length: 75Connection: keep-aliveServer: nginx/1.0.15Date: Sun, 21 Apr 2019 08:26:27 GMTFSS-Proxy: Powered by 3420734.4862536.4739156var returnCitySN = &#123;"cip": "120.229.5.147", "cid": "CN", "cname": "CHINA"&#125;; 可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后，CMD 的内容将会作为参数传给 ENTRYPOINT，而这里 -i 就是新的 CMD，因此会作为参数传给 curl，从而达到了我们预期的效果。 场景二：应用运行前的准备工作启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。 比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。 此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。 这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 &lt;CMD&gt;）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的： 12345678FROM alpine:3.4...RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis...ENTRYPOINT ["docker-entrypoint.sh"]EXPOSE 6379CMD [ "redis-server" ] 可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 ENTRYPOINT 为 docker-entrypoint.sh脚本。 123456789#!/bin/sh...# allow the container to be started with `--user`if [ "$1" = 'redis-server' -a "$(id -u)" = '0' ]; then chown -R redis . exec su-exec redis "$0" "$@"fiexec "$@" 该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如： 12$ docker run -it redis iduid=0(root) gid=0(root) groups=0(root) ENV 设置环境变量格式有两种： ENV &lt;key&gt; &lt;value&gt; ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;... 这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。 12ENV VERSION=1.0 DEBUG=on \ NAME=&quot;Happy Feet&quot; 这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。 定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像 Dockerfile中，就有类似这样的代码： 123456789ENV NODE_VERSION 7.2.0RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz" \ &amp;&amp; curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc" \ &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \ &amp;&amp; grep " node-v$NODE_VERSION-linux-x64.tar.xz\$" SHASUMS256.txt | sha256sum -c - \ &amp;&amp; tar -xJf "node-v$NODE_VERSION-linux-x64.tar.xz" -C /usr/local --strip-components=1 \ &amp;&amp; rm "node-v$NODE_VERSION-linux-x64.tar.xz" SHASUMS256.txt.asc SHASUMS256.txt \ &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs 在这里先定义了环境变量 NODE_VERSION，其后的 RUN 这层里，多次使用 $NODE_VERSION 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 7.2.0 即可，Dockerfile 构建维护变得更轻松了。 下列指令可以支持环境变量展开： ADD、COPY、ENV、EXPOSE、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD。 可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。 ARG 构建参数格式：ARG &lt;参数名&gt;[=&lt;默认值&gt;] 构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。 Dockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 --build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。 在 1.13 之前的版本，要求 --build-arg 中的参数名，必须在 Dockerfile 中用 ARG 定义过了，换句话说，就是 --build-arg 指定的参数，必须在 Dockerfile 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 Dockerfile 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。 VOLUME 定义匿名卷格式为： VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...] VOLUME &lt;路径&gt; 之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。 1VOLUME /data 这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如： 1docker run -d -v mydata:/data xxxx 在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。 匿名卷一般保存在/var/lib/docker/volumes路径下。 EXPOSE 声明端口格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]。 EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P时，会自动随机映射 EXPOSE 的端口。 要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 WORKDIR 指定工作目录格式为 WORKDIR &lt;工作目录路径&gt;。 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。 之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误： 12RUN cd /appRUN echo "hello" &gt; world.txt 如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。 之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。 因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。 USER 指定当前用户格式：USER &lt;用户名&gt;[:&lt;用户组&gt;] USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。 当然，和 WORKDIR 一样，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。 123RUN groupadd -r redis &amp;&amp; useradd -r -g redis redisUSER redisRUN [ "redis-server" ] 如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 gosu。 12345678# 建立 redis 用户，并使用 gosu 换另一个用户执行命令RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis# 下载 gosuRUN wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64" \ &amp;&amp; chmod +x /usr/local/bin/gosu \ &amp;&amp; gosu nobody true# 设置 CMD，并以另外的用户执行CMD [ "exec", "gosu", "redis", "redis-server" ] HEALTHCHECK 健康检查格式： HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。 在没有 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。 而自 1.12 之后，Docker 提供了 HEALTHCHECK 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。 当在一个镜像指定了 HEALTHCHECK 指令后，用其启动容器，初始状态会为 starting，在 HEALTHCHECK 指令检查成功后变为 healthy，如果连续一定次数失败，则会变为 unhealthy。 HEALTHCHECK 支持下列选项： --interval=&lt;间隔&gt;：两次健康检查的间隔，默认为 30 秒； --timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒； --retries=&lt;次数&gt;：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。 和 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。 在 HEALTHCHECK [选项] CMD 后面的命令，格式和 ENTRYPOINT 一样，分为 shell 格式，和 exec 格式。命令的返回值决定了该次健康检查的成功与否：0：成功；1：失败；2：保留，不要使用这个值。 假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 curl 来帮助判断，其 Dockerfile 的 HEALTHCHECK 可以这么写： 1234FROM nginxRUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*HEALTHCHECK --interval=5s --timeout=3s \ CMD curl -fs http://localhost/ || exit 1 这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 curl -fs http://localhost/ || exit 1 作为健康检查命令。 使用 docker build 来构建这个镜像： 1$ docker build -t myweb:v1 . 构建好了后，我们启动一个容器： 1$ docker run -d --name web -p 80:80 myweb:v1 当运行该镜像后，可以通过 docker container ls 看到最初的状态为 (health: starting)： 123$ docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES03e28eb00bd0 myweb:v1 "nginx -g 'daemon off" 3 seconds ago Up 2 seconds (health: starting) 80/tcp, 443/tcp web 在等待几秒钟后，再次 docker container ls，就会看到健康状态变化为了 (healthy)： 123$ docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES03e28eb00bd0 myweb:v1 "nginx -g 'daemon off" 18 seconds ago Up 16 seconds (healthy) 80/tcp, 443/tcp web 如果健康检查连续失败超过了重试次数，状态就会变为 (unhealthy)。 为了帮助排障，健康检查命令的输出（包括 stdout 以及 stderr）都会被存储于健康状态里，可以用 docker inspect 来查看。 12345678910111213$ docker inspect --format '&#123;&#123;json .State.Health&#125;&#125;' web | python -m json.tool&#123; "FailingStreak": 0, "Log": [ &#123; "End": "2016-11-25T14:35:37.940957051Z", "ExitCode": 0, "Output": "&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n body &#123;\n width: 35em;\n margin: 0 auto;\n font-family: Tahoma, Verdana, Arial, sans-serif;\n &#125;\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n", "Start": "2016-11-25T14:35:37.780192565Z" &#125; ], "Status": "healthy"&#125; ONBUILD 为他人做嫁衣裳格式：ONBUILD &lt;其它指令&gt;。 ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。 Dockerfile 中的其它指令都是为了定制当前镜像而准备的，唯有 ONBUILD 是为了帮助别人定制自己而准备的。 假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 npm 进行包管理，所有依赖、配置、启动信息等会放到 package.json 文件里。在拿到程序代码后，需要先进行 npm install 才可以获得所有需要的依赖。然后就可以通过 npm start 来启动应用。因此，一般来说会这样写 Dockerfile： 1234567FROM node:slimRUN mkdir /appWORKDIR /appCOPY ./package.json /appRUN [ "npm", "install" ]COPY . /app/CMD [ "npm", "start" ] 把这个 Dockerfile 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 Dockerfile 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。 如果第一个 Node.js 项目在开发过程中，发现这个 Dockerfile 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 Dockerfile，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 Dockerfile 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 Dockerfile，而第二个项目的 Dockerfile 就会被自动修复。 那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 Dockerfile 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 Dockerfile 就会变为： 1234FROM node:slimRUN mkdir /appWORKDIR /appCMD [ "npm", "start" ] 这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 my-node 的话，各个项目内的自己的 Dockerfile 就变为： 1234FROM my-nodeCOPY ./package.json /appRUN [ "npm", "install" ]COPY . /app/ 基础镜像变化后，各个项目都用这个 Dockerfile 重新构建镜像，会继承基础镜像的更新。 那么，问题解决了么？没有。准确说，只解决了一半。如果这个 Dockerfile 里面有些东西需要调整呢？比如 npm install 都需要加一些参数，那怎么办？这一行 RUN 是不可能放入基础镜像的，因为涉及到了当前项目的 ./package.json，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 Dockerfile 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。 ONBUILD 可以解决这个问题。让我们用 ONBUILD 重新写一下基础镜像的 Dockerfile: 1234567FROM node:slimRUN mkdir /appWORKDIR /appONBUILD COPY ./package.json /appONBUILD RUN [ "npm", "install" ]ONBUILD COPY . /app/CMD [ "npm", "start" ] 这次我们回到原始的 Dockerfile，但是这次将项目相关的指令加上 ONBUILD，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 Dockerfile 就变成了简单地： 1FROM my-node 是的，只有这么一行。当在各个项目目录中，用这个只有一行的 Dockerfile 构建镜像时，之前基础镜像的那三行 ONBUILD 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 npm install，生成应用镜像。 Dockerfile 多阶段构建之前的做法在 Docker 17.05 版本之前，我们构建 Docker 镜像时，通常会采用两种方式： 全部放入一个 Dockerfile一种方式是将所有的构建过程编包含在一个 Dockerfile 中，包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来的一些问题： 镜像层次多，镜像体积较大，部署时间变长 源代码存在泄露的风险 例如，编写 app.go 文件，该程序输出 Hello World! 1234567package main import "fmt" func main()&#123; fmt.Printf("Hello World!");&#125; 编写 Dockerfile.one 文件 123456789101112131415FROM golang:1.9-alpineRUN apk --no-cache add git ca-certificatesWORKDIR /go/src/github.com/go/helloworld/COPY app.go .RUN go get -d -v github.com/go-sql-driver/mysql \ &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \ &amp;&amp; cp /go/src/github.com/go/helloworld/app /rootWORKDIR /root/CMD ["./app"] 构建镜像 1$ docker build -t go/helloworld:1 -f Dockerfile.one . 分散到多个 Dockerfile另一种方式，就是我们事先在一个 Dockerfile 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 Dockerfile 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂。 例如，编写 Dockerfile.build 文件 12345678910FROM golang:1.9-alpineRUN apk --no-cache add gitWORKDIR /go/src/github.com/go/helloworldCOPY app.go .RUN go get -d -v github.com/go-sql-driver/mysql \ &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . 编写 Dockerfile.copy 文件 123456789FROM alpine:latestRUN apk --no-cache add ca-certificatesWORKDIR /root/COPY app .CMD ["./app"] 新建 build.sh 12345678910111213#!/bin/shecho Building go/helloworld:builddocker build -t go/helloworld:build . -f Dockerfile.builddocker create --name extract go/helloworld:builddocker cp extract:/go/src/github.com/go/helloworld/app ./appdocker rm -f extractecho Building go/helloworld:2docker build --no-cache -t go/helloworld:2 . -f Dockerfile.copyrm ./app 现在运行脚本即可构建镜像 123$ chmod +x build.sh$ ./build.sh 对比两种方式生成的镜像大小 12345$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEgo/helloworld 2 f7cf3465432c 22 seconds ago 6.47MBgo/helloworld 1 f55d3e16affc 2 minutes ago 295MB 使用多阶段构建为解决以上问题，Docker v17.05 开始支持多阶段构建 (multistage builds)。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 Dockerfile： 例如，编写 Dockerfile 文件 123456789101112131415161718192021FROM golang:1.9-alpine as builderRUN apk --no-cache add gitWORKDIR /go/src/github.com/go/helloworld/RUN go get -d -v github.com/go-sql-driver/mysqlCOPY app.go .RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .FROM alpine:latest as prodRUN apk --no-cache add ca-certificatesWORKDIR /root/COPY --from=0 /go/src/github.com/go/helloworld/app .CMD ["./app"] 构建镜像 1$ docker build -t go/helloworld:3 . 对比三个镜像大小 123456$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEgo/helloworld 3 d6911ed9c846 7 seconds ago 6.47MBgo/helloworld 2 f7cf3465432c 22 seconds ago 6.47MBgo/helloworld 1 f55d3e16affc 2 minutes ago 295MB 很明显使用多阶段构建的镜像体积小，同时也完美解决了上边提到的问题。 只构建某一阶段的镜像我们可以使用 as 来为某一阶段命名，例如 1FROM golang:1.9-alpine as builder 例如当我们只想构建 builder 阶段的镜像时，增加 --target=builder 参数即可 1$ docker build --target builder -t username/imagename:tag . 构建时从其他镜像复制文件上面例子中我们使用 COPY --from=0 /go/src/github.com/go/helloworld/app . 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件。 1$ COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf 其它制作镜像的方式除了标准的使用 Dockerfile 生成镜像的方法外，由于各种特殊需求和历史原因，还提供了一些其它方法用以生成镜像。 从 rootfs 压缩包导入格式：docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]] 压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。压缩包将会在镜像 / 目录展开，并直接作为镜像第一层提交。 比如我们想要创建一个 OpenVZ 的 Ubuntu 14.04 模板的镜像： 12345$ docker import \ http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz \ openvz/ubuntu:14.04Downloading from http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gzsha256:f477a6e18e989839d25223f301ef738b69621c4877600ae6467c4e5289822a79B/78.42 MB 这条命令自动下载了 ubuntu-14.04-x86_64-minimal.tar.gz 文件，并且作为根文件系统展开导入，并保存为镜像 openvz/ubuntu:14.04。 导入成功后，我们可以用 docker image ls 看到这个导入的镜像： 123$ docker image ls openvz/ubuntuREPOSITORY TAG IMAGE ID CREATED SIZEopenvz/ubuntu 14.04 f477a6e18e98 55 seconds ago 214.9 MB 如果我们查看其历史的话，会看到描述中有导入的文件链接： 123$ docker history openvz/ubuntu:14.04IMAGE CREATED CREATED BY SIZE COMMENTf477a6e18e98 About a minute ago 214.9 MB Imported from http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz docker save 和 docker loadDocker 还提供了 docker save 和 docker load 命令，用以将镜像保存为一个文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。 保存镜像使用 docker save 命令可以将镜像保存为归档文件。 比如我们希望保存这个 alpine 镜像。 123$ docker image ls alpineREPOSITORY TAG IMAGE ID CREATED SIZEalpine latest baa5d63471ea 5 weeks ago 4.803 MB 保存镜像的命令为： 123$ docker save alpine -o filename$ file filenamefilename: POSIX tar archive 这里的 filename 可以为任意名称甚至任意后缀名，但文件的本质都是归档文件 注意：如果同名则会覆盖（没有警告） 若使用 gzip 压缩： 1$ docker save alpine | gzip &gt; alpine-latest.tar.gz 然后我们将 alpine-latest.tar.gz 文件复制到了到了另一个机器上，可以用下面这个命令加载镜像： 12$ docker load -i alpine-latest.tar.gzLoaded image: alpine:latest 如果我们结合这两个命令以及 ssh 甚至 pv 的话，利用 Linux 强大的管道，我们可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功能： 1docker save &lt;镜像名&gt; | bzip2 | pv | ssh &lt;用户名&gt;@&lt;主机名&gt; 'cat | docker load' 镜像的实现原理Docker 镜像是怎么实现增量的修改和维护的？ 每个镜像都由很多层次构成，Docker 使用 Union FS 将这些不同的层结合到一个镜像中去。 通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。 Docker 在 AUFS 上构建的容器也是利用了类似的原理。 操作 Docker 容器容器是 Docker 又一核心概念。 简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。 启动容器启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。 因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。 新建并启动所需要的命令主要为 docker run。 例如，下面的命令输出一个 “Hello World”，之后终止容器。 12$ docker run centos:7 echo 'hello world'hello world 这跟在本地直接执行 echo &#39;hello world&#39; 几乎感觉不出任何区别。 下面的命令则启动一个 bash 终端，允许用户进行交互。 12$ docker run -it centos:7 /bin/bash[root@e3571344ce1d /]# 其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。 在交互模式下，用户可以通过所创建的终端来输入命令，例如 1234[root@e3571344ce1d /]# pwd/[root@e3571344ce1d /]# lsanaconda-post.log bin dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var 当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括： 检查本地是否存在指定的镜像，不存在就从公有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 启动已终止容器可以利用 docker container start 命令，直接将一个已经终止的容器启动运行。 容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 ps 或 top 来查看进程信息。 1234[root@e3571344ce1d /]# ps PID TTY TIME CMD 1 pts/0 00:00:00 bash 19 pts/0 00:00:00 ps 可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。 后台运行更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。 下面举两个例子来说明一下。 如果不使用 -d 参数运行容器。 12345$ docker run ubuntu:18.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"hello worldhello worldhello worldhello world 容器会把输出的结果 (STDOUT) 打印到宿主机上面 如果使用了 -d 参数运行容器。 12$ docker run -d ubuntu:18.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a 此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 docker logs 查看)。 注： 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。 使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker container ls 命令来查看容器信息。 123$ docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES77b2dc01fe0f ubuntu:18.04 /bin/sh -c &apos;while tr 2 minutes ago Up 1 minute agitated_wright 要获取容器的输出信息，可以通过 docker container logs 命令。 12345$ docker container logs [container ID or NAMES]hello worldhello worldhello world. . . 终止容器可以使用 docker container stop 来终止一个运行中的容器。 此外，当 Docker 容器中指定的应用终结时，容器也自动终止。 例如只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。 终止状态的容器可以用 docker container ls -a 命令看到。例如 12345[Null@skyline docker]$ docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe3571344ce1d centos:7 "/bin/bash" 17 minutes ago Exited (127) 9 minutes ago suspicious_sutherland7c9ae0223286 centos:7 "echo 'hello world'" 19 minutes ago Exited (0) 19 minutes ago distracted_mendel4032f5abf6fa d3011c2bb38d "curl -s https://pv.…" 3 weeks ago Exited (0) 3 weeks ago angry_montalcini 处于终止状态的容器，可以通过 docker container start 命令来重新启动。 此外，docker container restart 命令会将一个运行态的容器终止，然后再重新启动它。 进入容器在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令，原因会在下面说明。 attach 命令下面示例如何使用 docker attach 命令。 123456789$ docker run -dit ubuntu243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550$ docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES243c32535da7 ubuntu:latest "/bin/bash" 18 seconds ago Up 17 seconds nostalgic_hypatia$ docker attach 243croot@243c32535da7:/# 注意： 如果从这个 stdin 中 exit，会导致容器的停止。 exec 命令-i -t 参数docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。 只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。 当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。 12345678910111213141516$ docker run -dit ubuntu69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6$ docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES69d137adef7a ubuntu:latest "/bin/bash" 18 seconds ago Up 17 seconds zealous_swirles$ docker exec -i 69d1 bashlsbinbootdev...$ docker exec -it 69d1 bashroot@69d137adef7a:/# 如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 docker exec 的原因。 更多参数说明请使用 docker exec --help 查看。 导出和导入容器导出容器如果要导出本地某个容器，可以使用 docker export 命令。 1234$ docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7691a814370e ubuntu:18.04 "/bin/bash" 36 hours ago Exited (0) 21 hours ago test$ docker export 7691a814370e &gt; ubuntu.tar 这样将导出容器快照到本地文件。 导入容器快照可以使用 docker import 从容器快照文件中再导入为镜像，例如 1234$ cat ubuntu.tar | docker import - test/ubuntu:v1.0$ docker image lsREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEtest/ubuntu v1.0 9d37a6082e97 About a minute ago 171.3 MB 此外，也可以通过指定 URL 或者某个目录来导入，例如 1$ docker import http://example.com/exampleimage.tgz example/imagerepo 注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。 删除容器可以使用 docker container rm 来删除一个处于终止状态的容器。例如 12$ docker container rm trusting_newtontrusting_newton 如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。 清理所有处于终止状态的容器用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。 1$ docker container prune 访问仓库仓库（Repository）是集中存放镜像的地方。 一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 dl.dockerpool.com/ubuntu 来说，dl.dockerpool.com 是注册服务器地址，ubuntu 是仓库名。 大部分时候，并不需要严格区分这两者的概念。 Docker Hub目前 Docker 官方维护了一个公共仓库 Docker Hub，其中已经包括了数量超过 15,000 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。 注册你可以在 https://hub.docker.com 免费注册一个 Docker 账号。 登录可以通过执行 docker login 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。 你可以通过 docker logout 退出登录。 拉取镜像你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。 例如以 centos 为关键词进行搜索： 1234567$ docker search centosNAME DESCRIPTION STARS OFFICIAL AUTOMATEDcentos The official build of CentOS. 465 [OK]tianon/centos CentOS 5 and 6, created using rinse instea... 28blalor/centos Bare-bones base CentOS 6.5 image 6 [OK]saltstack/centos-6-minimal 6 [OK]tutum/centos-6.4 DEPRECATED. Use tutum/centos:6.4 instead. ... 5 [OK] 可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（OFFICIAL）、是否自动构建 （AUTOMATED）。 根据是否是官方提供，可将镜像分为两类。 一种是类似 centos 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。 还有一种类型，比如 tianon/centos 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 username/ 来指定使用某个用户提供的镜像，比如 tianon 用户。 另外，在查找的时候通过 --filter=stars=N 参数可以指定仅显示收藏数量为 N 以上的镜像。 下载官方 centos 镜像到本地。 123456$ docker pull centosPulling repository centos0b443ba03958: Download complete539c0211cd76: Download complete511136ea3c5a: Download complete7064731afe90: Download complete 推送镜像用户也可以在登录后通过 docker push 命令来将自己的镜像推送到 Docker Hub。 以下命令中的 username 请替换为你的 Docker 账号用户名。 1234567891011121314$ docker tag ubuntu:18.04 username/ubuntu:18.04$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 18.04 275d79972a86 6 days ago 94.6MBusername/ubuntu 18.04 275d79972a86 6 days ago 94.6MB$ docker push username/ubuntu:18.04$ docker search usernameNAME DESCRIPTION STARS OFFICIAL AUTOMATEDusername/ubuntu 自动构建自动构建（Automated Builds）功能对于需要经常升级镜像内程序来说，十分方便。 有时候，用户构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。 而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 GitHub 或 BitBucket）上的项目，一旦项目发生新的提交 （commit）或者创建了新的标签（tag），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。 要配置自动构建，包括如下的步骤： 登录 Docker Hub； 在 Docker Hub 点击右上角头像，在账号设置（Account Settings）中关联（Linked Accounts）目标网站； 在 Docker Hub 中新建或选择已有的仓库，在 Builds 选项卡中选择 Configure Automated Builds； 选取一个目标网站中的项目（需要含 Dockerfile）和分支； 指定 Dockerfile 的位置，并保存。 之后，可以在 Docker Hub 的仓库页面的 Timeline 选项卡中查看每次构建的状态。 私有仓库有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。 本节介绍如何使用本地仓库。 docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 docker-registryv2.x 版本。 安装运行 docker-registry容器运行你可以通过获取官方 registry 镜像来运行。 1$ docker run -d -p 5000:5000 --restart=always --name registry registry 这将使用官方的 registry 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 /opt/data/registry 目录。 1234$ docker run -d \ -p 5000:5000 \ -v /opt/data/registry:/var/lib/registry \ registry 在私有仓库上传、搜索、下载镜像创建好私有仓库之后，就可以使用 docker tag 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 127.0.0.1:5000。 先在本机查看已有的镜像。 123$ docker image lsREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB 使用 docker tag 将 ubuntu:latest 这个镜像标记为 127.0.0.1:5000/ubuntu:latest。 格式为 docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]。 12345$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest$ docker image lsREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB127.0.0.1:5000/ubuntu:latest latest ba5877dc9bec 6 weeks ago 192.7 MB 使用 docker push 上传标记的镜像。 123456789$ docker push 127.0.0.1:5000/ubuntu:latestThe push refers to repository [127.0.0.1:5000/ubuntu]373a30c24545: Pusheda9148f5200b0: Pushedcdd3de0940ab: Pushedfc56279bbb33: Pushedb38367233d37: Pushed2aebd096e0e2: Pushedlatest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568 用 curl 查看仓库中的镜像。 12$ curl 127.0.0.1:5000/v2/_catalog&#123;"repositories":["ubuntu"]&#125; 这里可以看到 {&quot;repositories&quot;:[&quot;ubuntu&quot;]}，表明镜像已经被成功上传了。 先删除已有镜像，再尝试从私有仓库中下载这个镜像。 1234567891011121314$ docker image rm 127.0.0.1:5000/ubuntu:latest$ docker pull 127.0.0.1:5000/ubuntu:latestPulling repository 127.0.0.1:5000/ubuntu:latestba5877dc9bec: Download complete511136ea3c5a: Download complete9bad880da3d2: Download complete25f11f5fb0cb: Download completeebc34468f71d: Download complete2318d26665ef: Download complete$ docker image lsREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE127.0.0.1:5000/ubuntu:latest latest ba5877dc9bec 6 weeks ago 192.7 MB 注意事项如果你不想使用 127.0.0.1:5000 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 192.168.199.100:5000 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。 这是因为 Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 HTTPS 访问的私有仓库。 Centos 7对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件） 12345678&#123; "registry-mirror": [ "https://registry.docker-cn.com" ], "insecure-registries": [ "192.168.199.100:5000" ]&#125; 注意：该文件必须符合 json 规范，否则 Docker 将不能启动。 其他对于 Docker for Windows 、 Docker for Mac 在设置中编辑 daemon.json 增加和上边一样的字符串即可。 Nexus3.x 的私有仓库使用 Docker 官方的 Registry 创建的仓库面临一些维护问题。比如某些镜像删除以后空间默认是不会回收的，需要一些命令去回收空间然后重启 Registry 程序。在企业中把内部的一些工具包放入 Nexus 中是比较常见的做法，最新版本 Nexus3.x 全面支持 Docker 的私有镜像。所以使用 Nexus3.x 一个软件来管理 Docker , Maven , Yum , PyPI 等是一个明智的选择。 启动 Nexus 容器1234$ docker run -d --name nexus3 --restart=always \ -p 8081:8081 \ --mount src=nexus-data,target=/nexus-data \ sonatype/nexus3 等待 3-5 分钟，如果 nexus3 容器没有异常退出，那么你可以使用浏览器打开 http://YourIP:8081 访问 Nexus 了。 第一次启动 Nexus 的默认帐号是 admin 密码是 admin123 登录以后点击页面上方的齿轮按钮进行设置。 创建仓库创建一个私有仓库的方法： Repository-&gt;Repositories 点击右边菜单 Create repository 选择 docker (hosted) Name: 仓库的名称 HTTP: 仓库单独的访问端口 Enable Docker V1 API: 如果需要同时支持 V1 版本请勾选此项（不建议勾选）。 Hosted -&gt; Deployment pollcy: 请选择 Allow redeploy 否则无法上传 Docker 镜像。 其它的仓库创建方法请各位自己摸索，还可以创建一个 docker (proxy) 类型的仓库链接到 DockerHub 上。再创建一个 docker (group) 类型的仓库把刚才的 hosted 与 proxy 添加在一起。主机在访问的时候默认下载私有仓库中的镜像，如果没有将链接到 DockerHub 中下载并缓存到 Nexus 中。 添加访问权限菜单 Security-&gt;Realms 把 Docker Bearer Token Realm 移到右边的框中保存。 添加用户规则：菜单 Security-&gt;Roles-&gt;Create role 在 Privlleges 选项搜索 docker 把相应的规则移动到右边的框中然后保存。 添加用户：菜单 Security-&gt;Users-&gt;Create local user 在 Roles 选项中选中刚才创建的规则移动到右边的窗口保存。 Docker 主机访问镜像仓库如果不启用 SSL 加密可以通过前面章节的方法添加信任地址到 Docker 的配置文件中然后重启 Docker。 使用 docker login YourDomainName OR HostIP 进行测试，用户名密码填写上面 Nexus 中生成的。 Docker 数据管理如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有两种方式： 数据卷（Volumes） 挂载主机目录 (Bind mounts) 数据卷数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： 数据卷 可以在容器之间共享和重用 对 数据卷 的修改会立马生效 对 数据卷 的更新，不会影响镜像 数据卷 默认会一直存在，即使容器被删除 注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷。 创建一个数据卷1$ docker volume create my-vol 查看所有的 数据卷 123$ docker volume lslocal my-vol 在主机里使用以下命令可以查看指定 数据卷 的信息 1234567891011$ docker volume inspect my-vol[ &#123; "Driver": "local", "Labels": &#123;&#125;, "Mountpoint": "/var/lib/docker/volumes/my-vol/_data", "Name": "my-vol", "Options": &#123;&#125;, "Scope": "local" &#125;] 启动一个挂载数据卷的容器在用 docker run 命令的时候，使用 --mount 标记来将 数据卷 挂载到容器里。在一次 docker run 中可以挂载多个 数据卷。 下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。 123456$ docker run -d -P \ --name web \ # -v my-vol:/wepapp \ --mount source=my-vol,target=/webapp \ training/webapp \ python app.py 查看数据卷的具体信息在主机里使用以下命令可以查看 web 容器的信息 1$ docker inspect web 数据卷 信息在 “Mounts” Key 下面 123456789101112"Mounts": [ &#123; "Type": "volume", "Name": "my-vol", "Source": "/var/lib/docker/volumes/my-vol/_data", "Destination": "/app", "Driver": "local", "Mode": "", "RW": true, "Propagation": "" &#125;], 删除数据卷1$ docker volume rm my-vol 数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。 无主的数据卷可能会占据很多空间，要清理请使用以下命令 1$ docker volume prune 挂载主机目录挂载一个主机目录作为数据卷使用 --mount 标记可以指定挂载一个本地主机的目录到容器中去。 123456$ docker run -d -P \ --name web \ # -v /src/webapp:/opt/webapp \ --mount type=bind,source=/src/webapp,target=/opt/webapp \ training/webapp \ python app.py 上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 --mount 参数时如果本地目录不存在，Docker 会报错。 Docker 挂载主机目录的默认权限是 读写，用户也可以通过增加 readonly 指定为 只读。 123456$ docker run -d -P \ --name web \ # -v /src/webapp:/opt/webapp:ro \ --mount type=bind,source=/src/webapp,target=/opt/webapp,readonly \ training/webapp \ python app.py 加了 readonly 之后，就挂载为 只读 了。如果你在容器内 /opt/webapp 目录新建文件，会显示如下错误 12/opt/webapp # touch new.txttouch: new.txt: Read-only file system 查看数据卷的具体信息在主机里使用以下命令可以查看 web 容器的信息 1$ docker inspect web 挂载主机目录 的配置信息在 “Mounts” Key 下面 12345678910"Mounts": [ &#123; "Type": "bind", "Source": "/src/webapp", "Destination": "/opt/webapp", "Mode": "", "RW": true, "Propagation": "rprivate" &#125;], 挂载一个本地主机文件作为数据卷--mount 标记也可以从主机挂载单个文件到容器中 123456789$ docker run --rm -it \ # -v $HOME/.bash_history:/root/.bash_history \ --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \ ubuntu:18.04 \ bashroot@2affd44b4667:/# history1 ls2 diskutil list 这样就可以记录在容器输入过的命令了。 Docker 中的网络功能介绍Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。 外部访问容器容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。 当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。 使用 docker container ls 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。 12345$ docker run -d -P training/webapp python app.py$ docker container ls -lCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESbc533791f3f5 training/webapp:latest python app.py 5 seconds ago Up 2 seconds 0.0.0.0:49155-&gt;5000/tcp nostalgic_morse 同样的，可以通过 docker logs 命令来查看应用的信息。 1234$ docker logs -f nostalgic_morse* Running on http://0.0.0.0:5000/10.0.2.2 - - [23/May/2014 20:16:31] "GET / HTTP/1.1" 200 -10.0.2.2 - - [23/May/2014 20:16:31] "GET /favicon.ico HTTP/1.1" 404 - -p 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort。 映射所有接口地址使用 hostPort:containerPort 格式本地的 5000 端口映射到容器的 5000 端口，可以执行 1$ docker run -d -p 5000:5000 training/webapp python app.py 此时默认会绑定本地所有接口上的所有地址。 映射到指定地址的指定端口可以使用 ip:hostPort:containerPort 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1 1$ docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py 映射到指定地址的任意端口使用 ip::containerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。 1$ docker run -d -p 127.0.0.1::5000 training/webapp python app.py 还可以使用 udp 标记来指定 udp 端口 1$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py 查看映射端口配置使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址 12$ docker port nostalgic_morse 5000127.0.0.1:49155. 注意： 容器有自己的内部网络和 ip 地址（使用 docker inspect 可以获取所有的变量，Docker 还可以有一个可变的网络配置。） -p 标记可以多次使用来绑定多个端口 例如 12345$ docker run -d \ -p 5000:5000 \ -p 3000:80 \ training/webapp \ python app.py 容器互联如果你之前有 Docker 使用经验，你可能已经习惯了使用 --link 参数来使容器互联。 随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 --link 参数。 新建网络下面先创建一个新的 Docker 网络。 1$ docker network create -d bridge my-net -d 参数指定 Docker 网络类型，有 bridge overlay。其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。 连接容器运行一个容器并连接到新建的 my-net 网络 1$ docker run -it --rm --name busybox1 --network my-net busybox sh 打开新的终端，再运行一个容器并加入到 my-net 网络 1$ docker run -it --rm --name busybox2 --network my-net busybox sh 再打开一个新的终端查看容器信息 12345$ docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb47060aca56b busybox "sh" 11 minutes ago Up 11 minutes busybox28720575823ec busybox "sh" 16 minutes ago Up 16 minutes busybox1 下面通过 ping 来证明 busybox1 容器和 busybox2 容器建立了互联关系。 在 busybox1 容器输入以下命令 1234/ # ping busybox2PING busybox2 (172.19.0.3): 56 data bytes64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms 用 ping 来测试连接 busybox2 容器，它会解析成 172.19.0.3。 同理在 busybox2 容器执行 ping busybox1，也会成功连接到。 1234/ # ping busybox1PING busybox1 (172.19.0.2): 56 data bytes64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms 这样，busybox1 容器和 busybox2 容器建立了互联关系。 Docker Compose如果你有多个容器之间需要互相连接，推荐使用 Docker Compose。 配置 DNS如何自定义配置容器的主机名和 DNS 呢？秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。 在容器中使用 mount 命令可以看到挂载信息： 1234$ mount/dev/disk/by-uuid/1fec...ebdf on /etc/hostname type ext4 .../dev/disk/by-uuid/1fec...ebdf on /etc/hosts type ext4 ...tmpfs on /etc/resolv.conf type tmpfs ... 这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 /etc/resolv.conf 文件立刻得到更新。 配置全部容器的 DNS ，也可以在 /etc/docker/daemon.json 文件中增加以下内容来设置。 123456&#123; "dns" : [ "114.114.114.114", "8.8.8.8" ]&#125; 这样每次启动的容器 DNS 自动配置为 114.114.114.114 和 8.8.8.8。使用以下命令来证明其已经生效。 1234$ docker run -it --rm ubuntu:18.04 cat etc/resolv.confnameserver 114.114.114.114nameserver 8.8.8.8 如果用户想要手动指定容器的配置，可以在使用 docker run 命令启动容器时加入如下参数： -h HOSTNAME 或者 --hostname=HOSTNAME 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。但它在容器外部看不到，既不会在 docker container ls 中显示，也不会在其他的容器的 /etc/hosts 看到。 --dns=IP_ADDRESS 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。 --dns-search=DOMAIN 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。 注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 /etc/resolv.conf 来配置容器。 Docker 对容器资源进行限制（未完）限制容器能使用的 CPU 核数 上面讲述的 -c --cpu-shares参数只能限制容器使用 CPU 的比例，或者说优先级，无法确定地限制容器使用 CPU 的具体核数；从 1.13 版本之后，docker 提供了 --cpus 参数可以限定容器能使用的 CPU 核数。这个功能可以让我们更精确地设置容器 CPU 使用量，是一种更容易理解也因此更常用的手段。--cpus 后面跟着一个浮点数，代表容器最多使用的核数，可以精确到小数点二位，也就是说容器最小可以使用 0.01 核 CPU。比如，我们可以限制容器只能使用 1.5 核数 CPU。 在 docker 启动参数中，和内存限制有关的包括（参数的值一般是内存大小，也就是一个正数，后面跟着内存单位 b、k、m、g，分别对应 bytes、KB、MB、和 GB）： -m --memory：容器能使用的最大内存大小，最小值为 4m --memory-swap：容器能够使用的 swap 大小 --memory-swappiness：默认情况下，主机可以把容器使用的匿名页（anonymous page）swap 出来，你可以设置一个 0-100 之间的值，代表允许 swap 出来的比例]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VeeValidate 表单校验]]></title>
    <url>%2F2019%2F04%2F24%2FVeeValidate-%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[项目遇到要表单验证了。VeeValidate是Vue.js的验证库，它有很多验证规则，并支持自定义规则。它基于模板，因此它与HTML5验证API相似并且很熟悉。您可以验证HTML5输入以及自定义Vue组件，不用自己造轮子。本篇文章就记录这个插件的基本使用方法。 基本安装和简单使用 npm install vee-validate --save 安装vee-validate插件。 npm install vue-i18n --save安装vue国际化。在src下新建文件夹并且创建文件validator.js,然后再引用到mian.js中import &#39;./validator/validator.js&#39;。 123456789101112131415161718//validator.jsimport Vue from "vue";import VeeValidate from "vee-validate";import VueI18n from "vue-i18n";import zh_CN from "vee-validate/dist/locale/zh_CN";Vue.use(VueI18n);const i18n = new VueI18n(&#123; locale: "zh_CN"&#125;);Vue.use(VeeValidate, &#123; i18n, i18nRootKey: "validation", dictionary: &#123; zh_CN &#125;&#125;); 在from表单验证必填值的简单使用。 v-validate: v-validate是vue的指令添加到您希望验证的输入中，并确保您的输入具有name用于生成错误消息的属性。 然后，传递给指令一个rules字符串，其中包含由管道’ |’ 分隔的验证规则列表。比如使用required这个选项是必填项. data-vv-as： 当为这个输入生成任何错误消息时，它将使用该data-vv-as值而不是实际的字段名称，默认的错误提示都是英文，如果你设置了这个，错误提示字段名称它会提示data-vv-as值. v-show=”errors.has(‘remark’)”默认错误提示的标签不加载出来. errors.first(‘remark’)获取关于当前remark的第一个错误信息. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div class="fromdata"&gt; &lt;div class="fromItem"&gt; &lt;input name="name" type="text" v-model="name" placeholder=" 请输入姓名" v-validate="'required'" data-vv-as="姓名" &gt; &lt;span v-show="errors.has('name')" class="help"&gt;&#123;&#123; errors.first('name') &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class="fromItem"&gt; &lt;input name="age" type="text" v-model="age" placeholder="年龄" v-validate="'required'"&gt; &lt;span v-show="errors.has('age')" class="help"&gt;&#123;&#123; errors.first('age') &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;button @click="commitData"&gt;提交&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; name: "", age: "" &#125;; &#125;, methods: &#123; commitData() &#123; this.$validator.validateAll().then(result =&gt; &#123; if (result) &#123; alert("验证通过"); return; &#125; alert("请检查表单"); &#125;); &#125; &#125;&#125;;&lt;/script&gt; 自定义验证规则在validator.js文件中引入Validator 对象； 123456789101112131415161718192021222324252627282930import &#123; Validator &#125; from "vee-validate";/*自定义验证规则*/Validator.extend("mobile", &#123; getMessage: field =&gt; "电话号码格式不正确", validate: value =&gt; value.length === 11 &amp;&amp; /^((13|14|15|17|18)[0-9]&#123;1&#125;\d&#123;8&#125;)$/.test(value)&#125;);Validator.extend("chinese", &#123; getMessage: field =&gt; "只能填写中文", validate: value =&gt; /[^\u0000-\u00FF]/.test(value)&#125;);/*自定义错误消息*/const Dictionary = &#123; zh_CN: &#123; messages: &#123; required: () =&gt; "必填项。", &#125;, attributes: &#123; email: "邮箱", mobile: '电话号码', idCard: "身份证号码", &#125; &#125;&#125;;// 自定义validate error 信息Validator.localize(Dictionary); 在上面的那个v-validate指令使用后面添加你自定义的规则。温馨提示 自定义方法要放在自定义错误消息上面，要不错误信息会有问题。 一个组件下保证验证的name属性唯一，除非你需要特定联动效果。具体如何使用在本人的github上有😊一个小demo。地址 校验范围的设定当一个Vue组件中多个form表单,每个表单当然都有自己的请求。所以在这种情况下就需要给每个验证设置一个领域。给每个验证设置一个data-vv-scope属性。为这个领域取一个name在提交表单之前validateAll（）方法修改成validate(“name.*”)来进行过滤。这种验证的方式在上面👆给个地址也有用到。 需要更多就移步至VeeValidate官网]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所爱隔山海]]></title>
    <url>%2F2019%2F04%2F07%2F%E6%89%80%E7%88%B1%E9%9A%94%E5%B1%B1%E6%B5%B7%2F</url>
    <content type="text"><![CDATA[二〇一九年六月七日]]></content>
      <categories>
        <category>随笔生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于axios封装的请求]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%9F%BA%E4%BA%8Eaxios%E5%B0%81%E8%A3%85%E7%9A%84%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[axios非常方便，但是如果在每个组件中走一遍axios流程，最终又会写出“意大利面条”式的代码。况且很多时候在前端需要设置header，统一添加token，对异常进行处理等，所以最好对其进行封装。结合axios，能够很好的进行封装。最近项目中，前端遇到获取数据时来自各种不同的项目组，其中有一个提供空间数据的小组为了保证数据的安全性。需要在请求数据前先用规定用户名和密码请求一个token。然后将这个token当必传参数去请求空间数据。为方便同事的使用即封装了一个公共的请求方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//cudeAxios.jsimport axios from 'axios';//引入axios请求import Vue from 'vue';let vm = new Vue(&#123;&#125;);//定义vm 等于 vue/** * @description: 获取token * @param &#123;type&#125; * @return: */function getToken() &#123; return axios(&#123; method: "get", url: vm.usedUrl() + "getCubeDataAccessToken", &#125;) .then(res =&gt; &#123; return res; &#125;) .catch(error =&gt; &#123; reject(error); &#125;)&#125;;/** * @description: 获取块数据请求之前的token * @param &#123;type&#125; * @return: */function getCubeToken() &#123; let timestamp = new Date().getTime(); let user = &#123; userName: "user", passWord: "123456" &#125;; let params = &#123; time: timestamp, user: user.userName, secret: vm.md5(timestamp + user.passWord) &#125;; return axios(&#123; method: "get", url: "http://192.168.1.192:9000/ksj_api/getToken", params: params &#125;) .then(res =&gt; &#123; return res; &#125;) .catch(error =&gt; &#123; reject(error); &#125;);&#125;async function fetchPost(url, params) &#123; //判断是否传请求类型 if (!params.request_type) &#123;//否 params.request_type = 'post'//默认为post &#125; //判断请求类型为post或put if (params.request_type == 'post' || params.request_type == 'put') &#123;//是 var type = 'data';//以data形式传参 &#125; else &#123;//否 var type = 'params'//以params形式传参 &#125; //设置请求参数及类型等 let httpDefaultOpts = &#123; method: params.request_type,//请求类型 url: url,//请求链接 // timeout: 20 * 1000,//请求超时时间 [type]: '',//参数 &#125; //删除请求类型对象 delete params.request_type; //判断参数是否data形式 if (type == "data") &#123;//是 //转换为formData var formData = new FormData(); for(let i in params)&#123; formData.append(i,params[i]); &#125; let token = await getToken(); //添加token formData.append("token", token.data.data.data.token); &#125;else&#123; var formData =params; &#125; //设置请求参数值 httpDefaultOpts[type] = formData; //返回请求数据到promise return new Promise((resolve, reject) =&gt; &#123; //请求方法 axios(httpDefaultOpts).then(response =&gt; &#123; resolve(response) &#125;).catch((error) =&gt; &#123; //提示请求发生错误，请检查网络 vm.open4('请求发生错误,请检查网络'); reject(error);//请求失败数据返回 &#125;) &#125;)&#125;//返回axios请求，名为Ajaxexport default &#123; Ajax(url, params) &#123; return fetchPost(url, params); &#125;&#125;; 上面既然用到的export default导出对象。就顺便记录一下JavaScript中AMD和ES6模块的导入导出对比。import，export，export default属于ES6规范。import命令具有提升效果，会提升到整个模块的头部，首先执行。import是解构过程（是在编译阶段执行的） 12345678910111213//output.jsconst a = 'valueA1'export &#123;a&#125;import &#123;a&#125; from './output.js'//此处的import &#123;a&#125;和export &#123;a&#125;，两个a是一一对应关系console.log(a)//=&gt;valueA1//output.jsconst a = 'valueA1'export default&#123;a&#125;import a from './output.js'//此处的a和export default&#123;a&#125;，不是一个a，console.log(a)//=&gt;&#123; a: 'valueA1' &#125; require，exports，module.exports属于AMD规范。require是运行时调用.require是赋值过程.在最后写一个调用这个公共axios的例子。 123456789101112131415161718192021222324252627import cubeAxios from "@/assets/axios/cudeAxios"; /** * @description: 根据经纬度获取八级地址信息 * @param &#123;type&#125; 参数lonlat是一个[lan,lon] * @return: */ async getDivisionsByLatLon(lonlat) &#123; let vm = this; var params=&#123; request_type:cubeApi.getDivisionsByLatLon.request_type, paramCodeList:"KJ5008", coordinates:JSON.stringify(lonlat) &#125; let url = vm.cubeCommonUrl()+cubeApi.getDivisionsByLatLon.url; return new Promise((resolve, reject) =&gt; &#123; cubeAxios .Ajax(url, params) .then(res =&gt; &#123; console.log(res); resolve(res); &#125;) .catch(error =&gt; &#123; reject(error); &#125;); &#125;); &#125;, /**]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[往事尤存，未来可期—ZWG]]></title>
    <url>%2F2019%2F03%2F17%2F%E5%BE%80%E4%BA%8B%E5%B0%A4%E5%AD%98%EF%BC%8C%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F%E2%80%94ZWG%2F</url>
    <content type="text"><![CDATA[请在下方输入您的密钥，再继续查看。 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>随笔生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器indexDB的使用]]></title>
    <url>%2F2019%2F03%2F11%2F%E6%B5%8F%E8%A7%88%E5%99%A8indexDB%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本地存储介绍一下HTML5时代带来的本地化存储技术， localStorage 、sessionStorage、WebSQL、indexedDB等. localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 cookie数据始终在同源的http请求中携带(即使不需要)，即cookie在浏览器和服务器间来回传递。 IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近mongodb数据库。 我目前编写Vue项目中用于存储数据字典等。下面就是创建,获取，更新，写入等基本操作。编写公共方法，并注册到Vue的生命周期中。 12345678910111213141516171819202122232425262728293031323334353637install(Vue) &#123; //定义一个vue的全局变量，用于获取创建indexdb的生命周期 Vue.prototype.db=null; /** * @description: 初始化浏览器的indexdb数据库 * @param &#123;type&#125; * @return: */ Vue.prototype.initIndexDB = (callback) =&gt; &#123; /** * @description: //创建数据库，第一个是数据库名,第二个是数据库的版本号 * @param &#123;type&#125; * @return: 同时返回一个IDBOpenDBRequest对象用于操作数据库 */ const request = window.indexedDB.open('myDatabase', 1); request.onerror = function (event) &#123; console.log(event,'数据库打开报错'); &#125;; //数据库升级触发的事件，创建数据库也会触发这个事件 request.onupgradeneeded = function (event) &#123; console.log(event,"onupgradeneeded") Vue.prototype.db = event.target.result; //新建数据库以后，第一件事是新建对象仓库，先判断是否存在 if (!Vue.prototype.db.objectStoreNames.contains('person')) &#123; objectStore = Vue.prototype.db.createObjectStore('person', &#123; keyPath: 'id' &#125;); &#125; &#125; request.onsuccess = function (event) &#123; Vue.prototype.db = request.result; console.log(Vue.prototype.db,'数据库创建成功'); if(typeof callback === 'function')&#123; console.log('执行回调成功'); callback(); &#125; &#125;; &#125; &#125; 在App.vue去调用这个公共方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import axios from "axios";export default &#123; name: "App", mounted() &#123; //创建indexdb数据库 this.initIndexDB(this.initFun); &#125;, methods: &#123; /** * @description: 初始化方法 * @param &#123;type&#125; * @return: */ initFun() &#123; let vm = this; vm.getUploadData().then(res =&gt; &#123; console.log(vm.db); //向对象仓库写入数据记录。通过事务完成。 let objStore = vm.db .transaction(["person"], "readwrite") .objectStore("person"); console.log(res); let data = &#123; name: "oouyang", age: 17, id: "3" &#125;; //查询数据 let getRequest = objStore.get(4); getRequest.onsuccess = function(event) &#123; if (getRequest.result) &#123; //如果存在g更新数据 let updateRequest = objStore.put(&#123; id: 4, ...res.data &#125;); updateRequest.onsuccess = function(event) &#123; console.log("数据更新成功"); &#125;; updateRequest.onerror = function(event) &#123; console.log("数据更新失败"); &#125;; &#125; else &#123; //如果不存在，写入数据 let insertRequest = objStore.add(&#123; id: 4, ...res.data &#125;); insertRequest.onsuccess = function(event) &#123; console.log("数据写入成功"); &#125;; insertRequest.onerror = function(event) &#123; console.log("数据写入失败"); &#125;; &#125; &#125;; getRequest.onerror = function(event) &#123; console.log("获取数据事务失败"); &#125;; &#125;); &#125;, /** * @description: 获取数据 * @param &#123;type&#125; * @return: */ getUploadData() &#123; let vm = this; return new Promise((resolve, reject) =&gt; &#123; axios(&#123; method: "get", url: "http://39.108.100.163:8082/upload/getUploadByLimit" &#125;) .then(res =&gt; &#123; resolve(res); &#125;) .catch(error =&gt; &#123; reject(error); &#125;); &#125;); &#125; &#125;, destroyed() &#123; if (this.db) &#123; this.db.close(); console.log("断开连接缓存数据库！"); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二月三天法定假日的瞎想]]></title>
    <url>%2F2019%2F03%2F03%2F%E4%BA%8C%E6%9C%88%E4%B8%89%E5%A4%A9%E6%B3%95%E5%AE%9A%E5%81%87%E6%97%A5%E7%9A%84%E7%9E%8E%E6%83%B3%2F</url>
    <content type="text"><![CDATA[写在前面————趁着2月29.30.31连着3天假期。博主非要我写点东西。 当前时间：二月二十八日晚。 最后一次看见小波是在去年十月，当小波从网吧的门口走进来的时候，我还在操作着狐狸大杀特杀，手机貌似还在和小波通话，一边说你是傻*吗，我在网吧里面点，快过来，一边手上动作不停，用狐狸放着REQ。“这游戏真心带不动，认真点好吗！”。当时身边还有地信最丑，ZMN，和Energy。 小波刚走过来，我们打出了GG，这局游戏自然是输了。好在，我们已经习惯了这种输输输的节奏。 这时我才抬头大量小波，眼镜换成了圆框的，金色边，戴了个鸭舌帽，瘦瘦的，脖子上挂了个耳机，背个书包，一副年轻上班族的样子。一年多不见，当真也是变得人模狗样，没有了那种给人下句话就是：“老雍，我感觉我真的有点屌！”的感觉。 这时我很想起立给小波一个熊抱，毕竟上一次的分离就是拥抱。但是一看小波嬉皮笑脸的样子，算了，着实浪费感情。好像然后一起开了游戏。打吧打吧，吃了饭。后来怎么样，我已记不清楚。 正如记不清楚后来的事情，其实当时见面的情况。 我亦是记不住的，上面只是我的模拟，以及和小波平日里相处杜撰出来的。换了眼镜也是今晚开视频我才注意到，鸭舌帽是在大学就经常带，耳机是后面借给我用我才记得，身体瘦是一直都这样。 印象中的小波是这样的，今天开视频看见也是这样，想来那次见面应该也是这样。 和小波相处是件让人愉悦的事情，无他。 因为人在与比自己笨的人相处的时候，自然会更容易愉悦一点。 我和小波相识于大学。 那是一个晴朗/下雨/阴云密布/刮风/打雷的早上/中午/晚上/夜晚。 开玩笑的，我怎么可能记得什么时间怎么认识他的？？ 小波自然也早就忘得一干二净。 我们的认识。 就好像生活中很多事一样，自然而然就发生了。就如同吃饭睡觉学习上学毕业恋爱失恋求职辞职被辞旅游遇见分别升级掉段，一切是那么自然，又是那么的应该，貌似我们就应该认识，所以就认识了，该分离了，自然就分离了，至于小波为什么觉得我很好，我不知道，可能大部分原因是他觉得他比我帅吧，当然只是他觉得。就好比他觉得我大学四年一直喜欢同一个女同学。 大学生活，小波具体怎么和我一起度过的我是真的记不清楚了。没有过多的火花，也没有过多的悲伤。他的存在如同水一般自然，一开始觉得挺蠢的，到最后，依然觉得还是挺蠢的。 有一次： 把银行电话留成地信最丑，说“以后银行打电话就不会找到自己。” 有两次： 用自以为最帅的转身，做了最丑的上篮动作。 有三次： 操作着豹女当救世主。说，我真的觉得自己挺帅的。 有四次： 自己谈恋爱，出去玩，就会瞎逼动，不干正事。当然用他的话说这是个好人才会做的事。 有五次： 我们一起吃饭喝酒，小波永远是一开始一直吃饭，不喝不喝，这几天胃真的难受，待到大家都你来我往差不多了，小波突然声音大了起来：别趴着，起来继续啊。来干。 仅有的一次，临近毕业： 我们俩在酒店外面，找了个台阶，坐了下来，小波抱着我哭。小波一边哭一边对我：“雍，我TM每次看见你XXXXXXXX，我就想不通，你把我们当什么？？” 这里的XXX是我真的不知道他说了啥。 惊了，怎么突然GAYGAY的。毕业酒会良好的氛围都被搞没了？？ 宫斗戏的既视感？？ 只是，当时已经来不及细想。 我已是泪流满面， 我俩抱头痛哭，几年来未流过的泪水像夏日的烈阳，辣、烫、灼。 我一边哭一边忍着酒味把小波的一些东西记录在了手机备忘录。 日后翻看，只记了一句。如下： “小波讲的一定要记下来。”日期是2017年5月13日。至于小波讲了的话，一句没记。这个备忘录至今还留在我的手机里。 我不知道这算不算是男人之间的浪漫。 可能当时小波也是一句没讲，和我一样只记得哭了。我以为他讲了很多，也只是我的杜撰罢了。 至于酒会之后的事情，我已是记不清楚。 分离真的是个狠人 行笔至此，我已经很难再写下去了。 于是乎，世界也很理解我，时间迅速的到达了三月一日的晚上。 三天假期一晃而过，今夜的我又开始了写。 时间又过，今天已经是3月2号的夜晚。 和小波玩了几局游戏，很久没打了。但是自己的水平还是一如既往的稳定，让我很是欣慰。 不知怎的，满脑子是送离小波的情形。 那是2017年5月31日，下过雨的天，下过雨的地面，还在翻修的学校。 和我一起去送的还有地信最丑，TY。 一路无话，校门口。 公交车来了。 小波突然说：好像真的要说再见了。 红了眼眶。 拥抱。 上了公交。 迄今记得那晚，我们都喝多了，互相说了许多肝胆相照的话，也都哭了。 偶有闲时，很怀念。 以上都是这几夜的牢骚。 雍，于2019年3月，一个晴朗的晚上。]]></content>
      <categories>
        <category>随笔生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年终总结]]></title>
    <url>%2F2019%2F01%2F01%2F2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[请在下方输入您的密钥，再继续查看。 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>随笔生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[造塑料轮子至npm]]></title>
    <url>%2F2018%2F12%2F22%2F%E9%80%A0%E5%A1%91%E6%96%99%E8%BD%AE%E5%AD%90%E8%87%B3npm%2F</url>
    <content type="text"><![CDATA[maptalks插件库里面也有一个VectorLayer.但是我们后台路径数据没有提供里面的time属性。所以自己写了一个实现类型功能的插件。为方便使用，发布到npm中。 编写功能npm init 一路到底。编写index.js也就是插件的功能代码，详细代码已上传到我的github中。设置git repository仓库地址和keywords关键字作为这个包的索引。 README文档文档什么效果–怎么安装依赖–怎么使用–还有API。 设置npm账号首先，要在npm发布包，首先得注册一个账号（记得邮箱认证），与github一样，npm对于公共包是免费的。第二步，添加账号。输入命令npm adduser，然后键入你在npm上注册的账号和密码。另外，npm config ls可以查看你的npm配置。 接下来，使用npm publish就可以发布你的包了。发布与更新都是使用npm publish 命令，更新必须修改版本信息。 packages我的npm还有很多需要学习，es6转es5。babel配置不好导致github上demo失败。]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常见设计模式]]></title>
    <url>%2F2018%2F12%2F11%2F%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式听起来像很是高端的样子，其实呢，确实很提莫难啊啊啊啊。言归正传，所谓的设计模式也就是一些比较优秀的编程思想。有了这些思想加于利用到实际开发中，可以减少工作量（便于维护）。废话不多说直接进入主题。 工厂模式工厂模式，顾名思义，就是为了创造对象。也就是一些公共方法？？？工厂模式最重要的优点是：可以在父类实现一些相同的方法，而具体要实现的业务逻辑可以放在子类中，通过子类重写父类的方法，去实现自己的业务逻辑,减少冗余代码。 简单工厂模式12345678910111213141516function CarFactory (brand, price) &#123; var car = new Object(); car.brand = brand; car.price = price; car.getPrice = function () &#123; return this.price; &#125; return car; &#125; var car1 = CarFactory("牌子A", 10000); var car2 = CarFactory("牌子B", 20000); console.log(JSON.stringify(car1)); // &#123;"brand":"牌子A","price":10000&#125; console.log(JSON.stringify(car2)); // &#123;"brand":"牌子B","price":20000&#125; console.log(typeof car1); // object console.log(typeof car2); // object console.log(car1 instanceof Object); // true 函数CarFactory接受两个参数brand, price，最终返回一个对象。如果多次调用这个函数，每次将返回一个新的对象，这就跟工厂的生产线一样。 复杂工厂模式123456789101112131415161718192021222324252627282930313233function ComplexCarFactory(brand, price) &#123; this.brand = brand; this.price = price; &#125; ComplexCarFactory.prototype = &#123; constructor: ComplexCarFactory, sellCar: function()&#123; var speed = this.getSpeed(this.brand); console.log(this.brand + '的车子售价：' + this.price + '元人民币，限速' + speed + '公里每小时'); &#125;, getSpeed : function(brand)&#123; throw new Error("父类是抽象类不能直接调用，需要子类重写该方法"); &#125; &#125;; var CarChild = function(brand, price) &#123; this.brand = brand; this.price = price; // 继承构造函数父类中的属性和方法 ComplexCarFactory.call(this, brand, price); &#125;; // 子类继承父类原型方法 CarChild.prototype = Object.create(ComplexCarFactory.prototype); // CarChild 子类重写父类的方法 CarChild.prototype.getSpeed = function(brand)&#123; var speed = null; if(brand === '牌子C')&#123; return 100; &#125; return 50; &#125; var car3 = new CarChild("牌子C", 3000); console.log(car3); // CarChild &#123;brand: "牌子C", price: 3000&#125; console.log(car3.sellCar()); // 牌子C的车子售价：3000元人民币，限速50公里每小时 ComplexCarFactory为父类，CarChild为子类，CarChild继承自ComplexCarFactory。ComplexCarFactory不在进行对象实例化，只对创建过程中的一般性问题进行处理，ComplexCarFactory就像是Java中的抽象类，必须被子类重写，否则调用ComplexCarFactory的getSpeed方法时就会抛出异常。CarChild继承自ComplexCarFactory，同时重写了父类的方法，CarChild类实例后的对象之间是相互独立的，具体的业务逻辑会放在子类中进行编写。 单例模式单例模式思想在于保证一个特定类仅有一个实例，意味着当你第二次使用同一个类创建信对象时，应得到和第一次创建对象完全相同。单例模式在我们平时的应用中用的比较多的，相当于把我们的代码封装在一个起来，只是暴露一个入口，从而避免全部变量的污染。123456789101112131415161718192021var Singleton = function(name)&#123; this.name = name;&#125;;Singleton.prototype.getName = function()&#123; return this.name;&#125;// 获取实例对象var getInstance = (function() &#123; var instance = null; return function(name) &#123; if(!instance) &#123; instance = new Singleton(name); &#125; return instance; &#125;&#125;)();// 测试单例模式的实例var a = getInstance("aa");var b = getInstance("bb");console.log(b.getName()); // "aa"console.log(a === b); // true 实现一个单例模式，无非就是使用一个变量来标识该类是否被实例化，如果未被实例化的话，那么我们可以实例化一次，否则的话，直接返回已经被实例化的对象。 模块模式模块模式是为单例模式添加私有变量和私有方法，并减少全局变量的使用；使用场景，创建一个对象时，需要进行内部初始化，同时对内部属性跟方法有访问权限限制，就需要使用模块模式了。如下就是一个模块模式的代码结构：1234567891011121314var singleMode = (function()&#123; // 创建私有变量 var privateNum = 112; // 创建私有方法 function privateFunc()&#123;&#125;, // 创建公有方法 function publicMethod1()&#123;&#125;, function publicMethod2()&#123;&#125;, // 返回一个对象包含公有方法和属性 return &#123; publicMethod1: publicMethod1, publicMethod2: publicMethod2 &#125;;&#125;)(); 模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，先定义了私有变量和函数，供内部函数使用，然后将一个对象字面量作为函数的值返回，返回的对象字面量中只包含可以公开的属性和方法。这样的话，可以提供外部使用该方法；由于该返回对象中的公有方法是在匿名函数内部定义的，因此它可以访问内部的私有变量和函数。 代理模式代理模式的优点在于：代理对象可以代替本体对象被实例化，此时本体对象未真正实例化，等到合适时机再实例化。代理模式可以延迟创建开销很大的本体对象，他会把本体的实例化推迟到有方法被调用时。 图片加载使用图片是非常常见的场景，如果直接给img标签设置src属性，如果图片过大，或网速比较慢，图片在加载过程中会有一段时间的空白，用户体验不好。 123456789101112131415161718192021222324var myImage = (function()&#123; var imgNode = document.createElement("img"); document.body.appendChild(imgNode); return &#123; setSrc: function(src) &#123; imgNode.src = src; &#125; &#125;&#125;)();// 代理模式var ProxyImage = (function()&#123; var img = new Image(); img.onload = function()&#123; myImage.setSrc(this.src); &#125;; return &#123; setSrc: function(src) &#123; myImage.setSrc("http://img.lanrentuku.com/img/allimg/1212/5-121204193R0.gif"); img.src = src; &#125; &#125;&#125;)();// 调用方式ProxyImage.setSrc("https://www.baidu.com/img/bd_logo1.png"); myImage 函数只负责做一件事，创建img元素加入到页面中，其中的加载loading图片交给代理函数ProxyImage 去做，当图片加载成功后，代理函数ProxyImage 会通知及执行myImage 函数的方法，同时当以后不需要代理对象的话，我们直接可以调用本体对象的方法即可。 缓存代理对第一次运行的结果进行缓存，当再一次运行相同运算的时候，直接从缓存里面取，避免重复运算，如果运算非常复杂的话，对性能很耗费，那么使用缓存对象可以提高性能。以下是一个简单的例子123456789101112131415161718192021222324252627282930313233var mult = function()&#123; var a = 1; for(var i = 0,ilen = arguments.length; i &lt; ilen; i+=1) &#123; a = a*arguments[i]; &#125; return a;&#125;;// 计算加法var plus = function()&#123; var a = 0; for(var i = 0,ilen = arguments.length; i &lt; ilen; i+=1) &#123; a += arguments[i]; &#125; return a;&#125;// 代理函数var proxyFunc = function(fn) &#123; var cache = &#123;&#125;; // 缓存对象 return function()&#123; var args = Array.prototype.join.call(arguments,','); if(args in cache) &#123; return cache[args]; // 使用缓存代理 &#125; return cache[args] = fn.apply(this,arguments); &#125;&#125;;var proxyMult = proxyFunc(mult);console.log(proxyMult(1,2,3,4)); // 24console.log(proxyMult(1,2,3,4)); // 缓存取 24var proxyPlus = proxyFunc(plus);console.log(proxyPlus(1,2,3,4)); // 10console.log(proxyPlus(1,2,3,4)); // 缓存取 10 职责链模式策略模式 一、策略模式可以有效避免很多if条件语句 二、策略模式符合开放-封闭原则，使代码更容易理解和扩展 三、策略模式中的代码可以复用.表单检验是非常常见的功能。因为涉及到大量的验证规则，使用策略模式会非常便利。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 策略对象var strategys = &#123; isNotEmpty: function(value,errorMsg) &#123; if(value === '') &#123; return errorMsg; &#125; &#125;, // 限制最小长度 minLength: function(value,length,errorMsg) &#123; if(value.length &lt; length) &#123; return errorMsg; &#125; &#125;, // 手机号码格式 mobileFormat: function(value,errorMsg) &#123; if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123; return errorMsg; &#125; &#125; &#125;;var Validator = function()&#123; this.cache = []; // 保存效验规则&#125;;Validator.prototype.add = function(dom,rules) &#123; var self = this; for(var i = 0, rule; rule = rules[i++]; )&#123; (function(rule)&#123; var strategyAry = rule.strategy.split(":"); var errorMsg = rule.errorMsg; self.cache.push(function()&#123; var strategy = strategyAry.shift(); strategyAry.unshift(dom.value); strategyAry.push(errorMsg); return strategys[strategy].apply(dom,strategyAry); &#125;); &#125;)(rule); &#125;&#125;;Validator.prototype.start = function()&#123; for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) &#123; var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息 if(msg) &#123; return msg; &#125; &#125;&#125;;// 代码调用var registerForm = document.getElementById("registerForm");var validateFunc = function()&#123; var validator = new Validator(); // 创建一个Validator对象 /* 添加一些效验规则 */ validator.add(registerForm.userName,[ &#123;strategy: 'isNotEmpty',errorMsg:'用户名不能为空'&#125;, &#123;strategy: 'minLength:6',errorMsg:'用户名长度不能小于6位'&#125; ]); validator.add(registerForm.password,[ &#123;strategy: 'minLength:6',errorMsg:'密码长度不能小于6位'&#125;, ]); validator.add(registerForm.phoneNumber,[ &#123;strategy: 'mobileFormat',errorMsg:'手机号格式不正确'&#125;, ]); var errorMsg = validator.start(); // 获得效验结果 return errorMsg; // 返回效验结果&#125;;// 点击确定提交registerForm.onsubmit = function()&#123; var errorMsg = validateFunc(); if(errorMsg)&#123; alert(errorMsg); return false; &#125;&#125; 发布-订阅模式发布—订阅模式又叫观察者模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。eg:假设小🐶看上了一双鞋子，但该鞋子已经断货了，卖家承诺她到货通知。与此同时，小🐷、小🐒也关注了这双鞋子。在这个场景中，卖家就是发布者，小🐶，🐷，🐒等人都属于订阅者。当鞋子到货时，会依次通知到每个人。实现：1.首先要想好谁是发布者(比如上面的卖家)。2.然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者(比如上面的买家收藏了卖家的店铺，卖家通过收藏了该店铺的一个列表名单)。3.最后就是发布消息，发布者遍历这个缓存列表，依次触发里面存放的订阅者回调函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var Event = (function()&#123; var list = &#123;&#125;, listen, trigger, remove; listen = function(key,fn)&#123; if(!list[key]) &#123; // 如果还没有订阅过此类消息，给该类消息创建一个缓存列表 list[key] = []; &#125; list[key].push(fn); // 订阅消息添加到缓存列表 &#125;; trigger = function()&#123; var key = Array.prototype.shift.call(arguments), // 取出消息类型名称 fns = list[key]; // 取出该消息对应的回调函数的集合 // 如果没有订阅过该消息的话，则返回 if(!fns || fns.length === 0) &#123; return false; &#125; for(var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this,arguments); // arguments 是发布消息时附送的参数 &#125; &#125;; remove = function(key,fn)&#123; // 如果key对应的消息没有订阅过的话，则返回 var fns = list[key]; // 如果没有传入具体的回调函数，表示需要取消key对应消息的所有订阅 if(!fns) &#123; return false; &#125; if(!fn) &#123; fns &amp;&amp; (fns.length = 0); &#125;else &#123; for(var i = fns.length - 1; i &gt;= 0; i--)&#123; var _fn = fns[i]; if(_fn === fn) &#123; fns.splice(i,1);// 删除订阅者的回调函数 &#125; &#125; &#125; &#125;; return &#123; listen: listen, trigger: trigger, remove: remove &#125;&#125;)();// 测试代码如下：Event.listen("color",function(size) &#123; console.log("尺码为:"+size); // 打印出尺码为42&#125;);Event.trigger("color",42);]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express常用功能]]></title>
    <url>%2F2018%2F11%2F21%2Fexpress%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Express基于 Node.js 平台，快速、开放、极简的 Web开发框架.本篇文章实现连接mysql||mongodb数据库提供RESTful服务和文件上传。根据这两个功能和nginx搭建一个简易图片服务器。 helloworld安装npm install express --save. 123456789101112131415const express = require('express')const app = express()app.get('/', (req, res) =&gt;&#123;res.header('Access-Control-Allow-Origin', '*') //解决跨域问题 let userData=[ &#123;name:"oouyang",age:23&#125;, &#123;name:"zhangsan",age:22&#125; ] res.send(userData);&#125;)const port =8082;//开启监听app.listen(port, () =&gt; console.log('Example app listening on port'+port+' !')) 启动 node server.js 然后http://localhost:8082在浏览器中加载以查看输出。 集成数据库安装依赖并配置 npm install mysql123456789//数据库配置文件mysqlEngineconst mysql = require(&apos;mysql&apos;)var connection = mysql.createConnection(&#123; host: &apos;39.108.100.163&apos;, user: &apos;root&apos;, password: &apos;*******&apos;, database: &apos;test&apos;&#125;);module.exports =connection; 引用内置router中间件123456789101112131415161718192021222324252627//user.js文件const express = require('express')const router = express.Router()const connection = require('../uilts/mysqlEngine') //数据库配置//创建一个connectionconnection.connect(function (err) &#123; if (err) &#123; console.log('连接失败' + err); return; &#125; console.log('[connection connect] succeed!');&#125;);router.get('/getAllUser', (req, res, next) =&gt; &#123; res.header('Access-Control-Allow-Origin', '*') //解决跨域问题 let sql= 'SELECT * from user' //执行sql connection.query(sql, function (err, rows, fields) &#123; if (err) throw err //console.log('The solution is: ', rows[0]); res.send(rows); &#125;) connection.end() //关闭连接&#125;)module.exports= router 注册中间件1234567891011const express = require('express')const app = express()let userRouter = require('./routers/user.js')//注册app.use('/user', userRouter)const port =8082;//开启监听app.listen(port, () =&gt; console.log('Example app listening on port'+port+' !')) 启动 http://localhost:8082/user/getAllUser 文件上传安装依赖npm install --save multer multer12345678910111213141516171819202122232425262728293031323334const express = require('express')const router = express.Router()var fs = require('fs');var multer = require('multer') //文件上传var createFolder = function(folder)&#123; try&#123; fs.accessSync(folder) &#125;catch(e)&#123; fs.mkdirSync(folder) &#125;&#125;var uploadFolder="./upload/";createFolder(uploadFolder);//设置文件上传目录和文件名var storage = multer.diskStorage(&#123; destination: function (req, file, cb) &#123; cb(null, uploadFolder) &#125;, filename: function (req, file, cb) &#123; // cb(null, file.fieldname + '-' + Date.now()) cb(null, file.originalname) &#125; &#125;) var upload = multer(&#123; storage: storage &#125;) //文件上传router.post('/upload',upload.single('avatar'),(req,res)=&gt;&#123; //avatar 是文件的上传的name还需修改 res.send("上传成功aaaa") console.dir(req.file)&#125;)module.exports= router 上传页面1234567891011&lt;template&gt; &lt;div&gt; &lt;h3&gt;文件上传：&lt;/h3&gt; 选择一个文件上传: &lt;br /&gt; &lt;form action=&quot;http://localhost:8082/user/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;avatar&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot; /&gt; &lt;/form&gt; &lt;/div&gt;&lt;/template&gt; 图片服务目前还在开发中，说到就肯定做不到。]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遇见未知的自己]]></title>
    <url>%2F2018%2F10%2F21%2F%E9%81%87%E8%A7%81%E6%9C%AA%E7%9F%A5%E7%9A%84%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[来到深圳快两个月了，颓废也快两个月了。整天过的咸鱼般的生活，总是自嘲是码农，结果真成了只会command+c,command+v的农民。技术上可以说是完全没有提升，就连跟同事的关系都处的一塌糊涂。欧阳波，你真的过的越来越不像自己了。 甲方就一个需求，一个让领导满意的系统。多参加会议，了解领导的动向，慢慢的你就会发现领导的动向就是搞死我们。有钱幸不幸福我不晓得，没钱肯定不幸福。技术上的难题从来都不是真正的难题，最难的是人心。日子就像吃了睾丸素的长跑运动员，奔跑的速度远远超过了他的真实水平。他们一边痛骂官员们的贪污腐败，一边又鼓动年轻人一定要去当官，当官就能发大财。新入职的一个姑娘，在经理疯狂地追逐下，试用期还没到，就选择了离职转行。仪式感，说好听点是讲究生活品质，说难听点就是穷人瞎矫情。读书无用论，谁家的儿子初中辍学办了个工厂发了大财，谁家的闺女读了硕士读成了傻子。 （不遗憾的是）=&gt;{不过遗憾的是}。要说大学四年里，我有什么后悔与遗憾。不是没有好好学习，进而获得保研资格；也不是没能积攒人脉，赚得人生第一桶金；而是没能找寻到志同道合，三观一致，能携手相伴的姑娘。对于游戏，那真的是人菜瘾大。]]></content>
      <categories>
        <category>随笔生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目中常用模块]]></title>
    <url>%2F2018%2F08%2F29%2FVue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[最近被项目组安排到写前端，用的框架是vue。下面就记录一些常用的npm模块和vue相关的知识。 Mockjs模拟数据在后台接口未开发完成之前模拟数据，并返回，完成前台的交互；在后台数据完成之后，你所做的只是去掉mockjs：停止拦截真实的ajax，仅此而已。 安装与引用网站npm install mockjs --saveimport Mock from &#39;mockjs&#39; 运用实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;script&gt; import axios from "axios"; import Mock from 'mockjs' export default &#123; data() &#123; return &#123; userData: &#123; total: null, list: [] &#125; &#125;; &#125;, created() &#123; this.initGetData(); &#125;, methods: &#123; initGetData: function () &#123; new Promise((resolve, reject) =&gt; &#123;&#125;) .then(this.getUserData()) .catch( reject(error)//请求失败数据返回 ) &#125;, //Mock生成数据 templateFunction: () =&gt; &#123; const Random = Mock.Random; var id = 0; var len = 10; let data = &#123; code: 1000, msg: '成功', total: len, data: new Array() &#125; for (var i = 0; i &lt; len; i++) &#123; var obj = new Object(); obj.id = id++; obj.age = Random.integer(18, 25);//生成1-5随机值 obj.password = Random.natural();//生成16位随机值 obj.username = Random.ctitle();//生成4位中文 obj.time = Random.date('yyyy-MM-dd');//生成日期 obj.describe = Random.cparagraph();//生成一句话 data.data.push(obj); &#125; return data; &#125;, getUserData() &#123; var vm = this; //Mock.mock(rurl,template) Mock.mock("getAllUserData", vm.templateFunction); axios.get("getAllUserData").then(res =&gt; &#123; console.log(res); vm.userData.total = res.data.total; vm.userData.list = res.data.data; &#125;) &#125;, &#125; &#125;;&lt;/script&gt; Mock.mock(rurl,template)重点就是写数据模板。当拦截到匹配 rurl 的 Ajax 请求时，将根据数据模板 template 生成模拟数据，并作为响应数据返回。通过axios请求设置的那个rurl。userData可以获取到10条随机数据。 代理服务器express和http-proxy-middleware创建代理服务器起因：发布wmts服务不管通过怎么样的方式去调用都出现跨域的问题。跨域的原因都是浏览器的同源策略，域名、协议、端口相同。解决方案：创建代理服务器，服务器不存在跨域问题，所以可以由服务器请求所要域的资源再返回给客户端。 123456789101112131415161718192021222324const express = require('express')var proxy = require('http-proxy-middleware');const app = express()// proxy middleware optionsvar options = &#123; //此处地址是公司的wmts，需要vpn访问。 target: 'http://172.17.0.179/ArcGIS/rest/services/FTKSJ/NANSHAN_CGCS2000/MapServer', // target host changeOrigin: true, // needed for virtual hosted sites ws: true, // proxy websockets pathRewrite: &#123; // '^/api/old-path': '/api/new-path', // rewrite path // '^/api/remove/path': '/path', // remove base path "^/api": "" &#125;&#125;// create the proxy (without context)var exampleProxy = proxy(options)app.use('/api', exampleProxy);const port = 8081;//开启监听app.listen(port, () =&gt; console.log('Example app listening on port' + port + ' !')) 访问 localhost:8081/api就相当于访问了target指向的地址。上面这个🌰也只是用到http-proxy-middleware的一些皮毛。更多高级功能去npm&amp;&amp;github中查看。 vue项目设置代理用vue-cli搭建的项目内置集成了http-proxy-middleware,所以找到config📁下的index.js中的proxyTable属性添加。 123456789101112proxyTable: &#123; /** * 设置武汉地图服务的代理，避免跨域。--oouyang */ '/api': &#123; target: 'http://172.17.0.179/ArcGIS/rest/services/FTKSJ/NANSHAN_CGCS2000/MapServer', changeOrigin: false, pathRewrite: &#123; "^/api": "" &#125; &#125; &#125;, 自定义指令有的情况下，需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。比如鼠标的焦点事件。 钩子函数一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind:只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted:被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update:所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated:指令所在组件的 VNode 及其子 VNode 全部更新后调用. unbind:只调用一次，指令与元素解绑时调用。 钩子函数参数 el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 自定义指令的应用需求：点击button，显示一个div，再点击div以外的空白处，隐藏这个div。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;template&gt; &lt;div v-clickoutside="handleClose"&gt; &lt;div class="tree_input" @click="showTree"&gt; &lt;p&gt;请选择&lt;/p&gt; &lt;/div&gt; &lt;transition name="fade"&gt; &lt;div class="tree" id="tree" v-if="treeShow"&gt; 用于显示隐藏的div &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; treeShow: false, //控制div的显示隐藏 &#125;; &#125;, directives: &#123; clickoutside: &#123; // 初始化指令 bind(el, binding, vnode) &#123; function documentHandler(e) &#123; // 这里判断点击的元素是否是本身，是本身，则返回 if (el.contains(e.target)) &#123; return false; &#125; // 判断指令中是否绑定了函数 if (binding.expression) &#123; // 如果绑定了函数 则调用那个函数，此处binding.value就是handleClose方法 binding.value(e); &#125; &#125; // 给当前元素绑定个私有变量，方便在unbind中可以解除事件监听 el.__vueClickOutside__ = documentHandler; document.addEventListener("click", documentHandler); &#125;, update() &#123;&#125;, unbind(el, binding) &#123; // 解除事件监听 document.removeEventListener("click", el.__vueClickOutside__); delete el.__vueClickOutside__; &#125; &#125; &#125;, methods: &#123; handleClose(event) &#123; this.treeShow = false; &#125;, showTree() &#123; this.treeShow = true; &#125; &#125;&#125;;&lt;/script&gt; 封装Vue的公共方法]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以后，广州见]]></title>
    <url>%2F2018%2F08%2F07%2F%E4%BB%A5%E5%90%8E%EF%BC%8C%E5%B9%BF%E5%B7%9E%E8%A7%81%2F</url>
    <content type="text"><![CDATA[是的，我离职了。按照套路来说，应该先感谢一波公司，领导。但是我最想谢的还是跟我一起相处时间最长的同事伙伴们。最近一段时间都是处于焦虑状态，几乎每天凌晨三点都会醒来。不是因为工作上的压力，而是对面这世界时我内心的无助感。算了，不装逼了。由于我是公司唯一的gis开发人员。所以我在整个办公室里面对所有人都有或多或少的接触。俊哥，谢谢你对我的理解和帮助，让我在规定时间胜利入职新的一家公司。一个会做油焖大虾的大厨，以后部门的活动可以让俊哥给你们秀一波操作。小胡，你来到公司的时间不长，却帮我省下来一大笔外卖费。一个女孩平时看起来大大咧咧的，在叫外卖时却”斤斤计较”。所以啊女人心，海底针。悦姐，公司的UI，从需求到界面掌握着全办公室前端开发人员的生死大权。早子，测试小姐姐，不管三七二十一只要领导说哪里有问题就找前端的责任（因为后台我也测不了~~可爱卖萌风格）。黄主管，跟我一个宿舍最长时间，晚上几乎两点之后睡。周末从不出门除非大事。但工作认真负责（这个品质是我们全办公室人员的通病，除了狗杨，因为他先溜了，写的官网不符合悦姐的要求）。晨哥，他懂的真的好多，感觉什么都知道，但我真的有丶不喜欢磨磨唧唧（指生活方面）。不要沉迷于学习，记得要多锻炼身体。胡哥，下班就溜，或许这就是真大神的风格，最短的时间做最多的事。刚子，来公司坐你旁边应该是最长时间了，人真的超好的，周末你回家我就骑你的小电驴出去玩嘻嘻。华哥，平台进度控制者。强云，刚来的时候叫你强哥，但是我发现你比我还小，叫你哥感觉gaygay的。工作上和你接触应该是最多的，毕竟一个页面长达4000+代码（本想着把代码重构一下，但我能力有限，怕被我玩崩了）。合作愉快。还有好多好多人，好多好多故事。写也写不完，道也道不尽，之前如有得罪的地方，谢谢你们的宽容。午时已到。我要走了，以后广州的大保健里面的店里见。]]></content>
      <categories>
        <category>随笔生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2018%2F07%2F24%2Fubuntu%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[ubuntu搭建git服务器git服务器github上传和拉取代码速度是比较慢的，在Github上创建一个私有仓库是收费的。GitBucket是一个开源的代码管理仓库，就像GitHub一样。 下载并上传选择版本，下载gitbucket.war下载链接使用Xftp将war上传到ubuntu服务器上。 安装gitbucket首先查看是否安装java环境。安装java环境找到你上传过来的war。执行nohup java -jar gitbucket.war 验尸http://39.108.100.163:8080我已经创建一个游客账号，可以查看一些公共项目。username：testpassword：qwer 开启pages服务1.下载gitbucket-pages-plugin插件jar地址2.将jar文件复制到&lt;GITBUCKET_HOME&gt;/plugins/（GITBUCKET_HOME默认为~/.gitbucket）查找plugins文件夹在ubuntu上的哪个位置find / -name &#39;plugins&#39; -type d用xftp拖到plugins目录下。3.重新启动gitbucketnohup java -jar gitbucket.war --port 8088这里设置的端口号似乎没有用。还是会启动为8080端口。4.用游客账号创建一个公开的oouyang仓库。创建一个gh-pages孤儿分支，并设置为默认分支。 从图片可以看到多了一个pages的功能。（也可以选择master分支为page功能。就不需要创建孤儿分支了。）5.colne 这个分支并上传一些页面。访问：打开浏览器并指向 /pages git常用命令 图中几个名词： Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 12345678910111213141516171819# 下载一个项目和它的整个代码历史$ git clone [url]# 添加当前目录的所有文件到暂存区$ git add .# 提交暂存区到仓库区$ git commit -m [message]# 推送到远程分支$ git push origin [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的sql语句]]></title>
    <url>%2F2018%2F07%2F13%2F%E5%B8%B8%E8%A7%81%E7%9A%84sql%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[多表查询从数据显示方式来讲有：内连接,外连接和交叉连接。内连接：只返回满足连接条件的数据。外连接：除了返回满足连接条的行以外，还返回左（右）表中，不满足条件的行，称为左（右）连接。123456789101112131415161718#内连接-- 等值连接SELECT * FROM `user` as a, lnglat as b WHERE a.id= b.userid;-- 自然连接SELECT * FROM `user` as a INNER JOIN lnglat as b on a.id=b.userid ;#外连接-- 左连接select * FROM `user` as a LEFT JOIN lnglat as b on a.id=b.userid AND b.type=1;-- 右连接SELECT * FROM `user` as a RIGHT JOIN lnglat as b on a.id=b.userid;-- 全连接-- mysql不支持,所以用union联合查询SELECT * FROM `user` as a LEFT JOIN lnglat as b on a.id=b.userid UNION SELECT * FROM `user` as a RIGHT JOIN lnglat as b on a.id=b.userid ;#交叉连接(笛卡尔积)SELECT * FROM `user` as a ,lnglat as b;SELECT * FROM `user`as a CROSS JOIN lnglat as b;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu安装geoserver]]></title>
    <url>%2F2018%2F06%2F15%2Fubuntu%E5%AE%89%E8%A3%85geoserver%2F</url>
    <content type="text"><![CDATA[安装geoserver下载geoserver去官网下载你喜欢的版本。 上传到ubuntu用Xshell登录到服务器，然后使用sftp将下载的文件上传到root目录下。 将你要上传的文件拉到这里面来就行了。 解压geoserver安装unzipapt-get install unzip解压zip文件unzip 压缩文件名.zip 这里可以看到上传过来的zip和解压之后的geoserver-2.11.1 安装java环境1.添加仓库源add-apt-repository ppa:webupd8team/java之前可能需要安装依赖包。2.更新软件包列表apt-get update3.安装JDK apt-get install oracle-java8-installer4.查看java版本，看看是否安装成功java-version 设置GEOSERVER_HOME环境变量vi /etc/profile 添加路径 保存修改重新生效source /etc/profile 启动geoserver启动：nohup ./startup.sh &amp;关闭：./shutdown.sh访问试试 部署SpringBoot项目idea打包成jar包maven工具先clean再package。maven命令打包，排除测试代码后进行打包mvn clean package -Dmaven.test.skip=true 上传到ubuntu上传之前先在本机上测试一下打包的jar是否能正常运行java -jar Name.jar上传方式与上面相同。 运行jar启动之前查看安装了Java环境，nohup java -jar Name.jarspringboot 查看进程并kill查看java的进程ps -ef|grep java1234root@iZi2m69ympwtuqZ:~# ps aux| grep javaroot 12194 0.1 39.6 2610948 812304 ? Sl Jun15 54:44 /usr/lib/jvm/java-8-oracle/bin/java -DGEOSERVER_DATA_DIR=/root/geoserver-2.11.1/data_dir -Djava.awt.headless=true -DSTOP.PORT=8079 -DSTOP.KEY=geoserver -jar start.jarroot 24255 16.2 10.1 2478560 208748 ? Sl 15:52 0:17 java -jar spring-boot-jpa-thymeleaf-curd-2.0.2.RELEASE.jarroot 24334 0.0 0.1 11764 2084 pts/2 S+ 15:54 0:00 grep --color=auto java 杀死pid为24255的进程kill -s 9 24255]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目部署到nginx服务器]]></title>
    <url>%2F2018%2F06%2F13%2Fvue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[去年就买了一个阿里云服务器，自从安装了mySQL数据库也就没有去发挥它的作用了。一直也想将vue开发的一个小项目部署到服务器上，有助于以后写文章时有个链接能直接看到效果，而不是图片了。下面就记录一下nginx部署一个项目的流程。直入主题 ubuntu安装nginx服务器sudo apt-get install nginx安装好的文件位置： /usr/sbin/nginx：主程序 /etc/nginx：存放配置文件 /usr/share/nginx：存放静态文件 /var/log/nginx：存放日志 其实从上面的根目录文件夹可以知道，Linux系统的配置文件一般放在/etc，日志一般放在/var/log，运行的程序一般放在/usr/sbin或者/usr/bin。 当然，如果要更清楚Nginx的配置项放在什么地方，可以打开/etc/nginx/nginx.conf。 Nginx指定默认加载/etc/nginx/nginx.conf的配置文件。如果要查看加载的是哪个配置文件，可以用这个命令sudo nginx -t或者ps -ef | grep nginx。 然后通过这种方式安装的，会自动创建服务，会自动在/etc/init.d/nginx新建服务脚本，然后就可以使用sudo service nginx {start|stop|restart|reload|force-reload|status|configtest|rotate|upgrade}的命令启动。下面是被我修改过的页面。 vue-cli打包成静态文件打包之前需要注意两个问题：1.记得改一下config下面的index.js中bulid模块导出的路径。因为index.html里边的内容都是通过script标签引入的，而你的路径不对，打开肯定是空白的。先看一下默认的路径。assetsPublicPath默认的是 / 也就是根目录。而我们的index.html和static在同一级目录下面。所以要改为 ./。2.src里边router/index.js路由配置里边默认模式是hash，如果你改成了history模式的话，打开也会是一片空白。所以改为hash或者直接把模式配置删除，让它默认的就行 。npm run build生成的dist文件先在本地看一下是否有效果然后上传到github上。 修改nginx的配置文件查看nginx.conf1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495user www-data;worker_processes 4;pid /run/nginx.pid;events &#123; worker_connections 768; # multi_accept on;&#125;http &#123; ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; gzip_disable "msie6"; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript; ## # nginx-naxsi config ## # Uncomment it if you installed nginx-naxsi ## #include /etc/nginx/naxsi_core.rules; ## # nginx-passenger config ## # Uncomment it if you installed nginx-passenger ## #passenger_root /usr; #passenger_ruby /usr/bin/ruby; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*;&#125;#mail &#123;# # See sample authentication script at:# # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript# # # auth_http localhost/auth.php;# # pop3_capabilities "TOP" "USER";# # imap_capabilities "IMAP4rev1" "UIDPLUS";# # server &#123;# listen localhost:110;# protocol pop3;# proxy on;# &#125;# # server &#123;# listen localhost:143;# protocol imap;# proxy on;# &#125;#&#125; 上面的文件重点就在这两句include /etc/nginx/conf.d/*.conf;include /etc/nginx/sites-enabled/*;第二句里面放着默认配置default123456789101112131415161718server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /usr/share/nginx/html; index index.html index.htm; # Make site accessible from http://localhost/ server_name localhost; location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; # Uncomment to enable naxsi on this location # include /etc/nginx/naxsi.rules &#125;&#125; 第一句文件的位置就是放自己配置的server。先将github上的打包的dist文件拉动服务器上来。放到下面的位置root@iZi2m69ympwtuqZ:/var/www/dist# pwd/var/www/distroot@iZi2m69ympwtuqZ:/var/www/dist# lsindex.html README.md static然后在/etc/nginx/conf.d 新建一个以。conf结尾文件root@iZi2m69ympwtuqZ:/etc/nginx/conf.d# vi vueapp.conf具体内容1234567891011121314151617upstream arcgis_server &#123; server demo-dx.geostar.com.cn:6234; &#125;server&#123; listen 8081; #监听端口 server_name 39.109.100.163;#监听地址 location /&#123; index index.html; #默认页面 root /var/www/dist;#根目录，也就是github拉下来文件的位置 &#125; # 配置一个代理 location /arcgis/ &#123; proxy_pass http://arcgis_server; &#125;&#125; 我也就是配置最最简单的。更详细配置查看官网 重启 nginx服务nginx -s reload然后访问测试去吧 nuxt项目部署流程搭建nginx+node+npm+pm2环境先在ubuntu上安装node环境。curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -sudo apt-get install -y nodejs查看node和npm版本nodejs -vnpm -version nuxt项目打包上传查看packpage.json12345678"scripts": &#123; "dev": "nuxt", "build": "nuxt build", "start": "nuxt start", "generate": "nuxt generate", "lint": "eslint --ext .js,.vue --ignore-path .gitignore .", "precommit": "npm run lint" &#125; 执行npm run build 生成.nuxt渲染文件。npm start本地是否正常运行。将项目中的.nuxt、static、nuxt.config.js、package.json四个文件上传到仓库。 pm2运行项目安装pm2：npm install pm2 -g。pm2常用命令1234567891011121314151617启动：pm2 start app.jspm2 start app.js --name my-api #my-api为PM2进程名称pm2 start app.js -i 0 #根据CPU核数启动进程个数pm2 start app.js --watch #实时监控app.js的方式启动，当app.js文件有变动时，pm2会自动reload查看进程:pm2 listpm2 show 0 或者 # pm2 info 0 #查看进程详细信息，0为PM2进程id 停止进程：pm2 stop all #停止PM2列表中所有的进程pm2 stop 0 #停止PM2列表中进程为0的进程重启：pm2 restart all #重启PM2列表中所有的进程pm2 restart 0 #重启PM2列表中进程为0的进程删除PM2进程：pm2 delete 0 #删除PM2列表中进程为0的进程pm2 delete all #删除PM2列表中所有的进程 在ubuntu上把仓库中文件clone下来。安装依赖:npm install。启动：npm start pm2启动:pm2 start npm --name &quot;my-nuxt&quot; -- run start ningx将pm2中运行的项目转发出去。在nginx的配置目录下新建一个nuxt.conf文件123456789101112131415161718upstream nodenuxt &#123; server 127.0.0.1:8089; #nuxt项目 监听端口 keepalive 64;&#125;server &#123; listen 8090; #你需要访问的端口 server_name 39.108.100.163; location / &#123; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header Host $host; proxy_set_header X-Nginx-Proxy true; proxy_cache_bypass $http_upgrade; proxy_pass http://nodenuxt; #反向代理 &#125;&#125; 重启nginx：nginx -s reloadhttp://39.108.100.163:8090这个项目目前还在开发中。后期会可能会正式上线。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot与Vue实现分页]]></title>
    <url>%2F2018%2F06%2F07%2FSpringBoot%E4%B8%8EVue%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[主要技术路线elementUI+axios+springboot提供分页测试数据接口地址。页面组件地址 element表格与对话框123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;template&gt;&lt;div&gt; &lt;el-table :data="tableData" style="width: 100%"&gt; &lt;el-table-column label="日期" width="180"&gt; &lt;template slot-scope="scope1"&gt; &lt;i class="el-icon-time"&gt;&lt;/i&gt; &lt;span style="margin-left: 10px"&gt;&#123;&#123; scope1.row.date &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label="姓名" width="180"&gt; &lt;template slot-scope="scope"&gt; &lt;el-popover trigger="hover" placement="top"&gt; &lt;p&gt;姓名: &#123;&#123; scope.row.name &#125;&#125;&lt;/p&gt; &lt;p&gt;住址: &#123;&#123; scope.row.address &#125;&#125;&lt;/p&gt; &lt;div slot="reference" class="name-wrapper"&gt; &lt;el-tag size="medium"&gt;&#123;&#123; scope.row.name &#125;&#125;&lt;/el-tag&gt; &lt;/div&gt; &lt;/el-popover&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label="地址" width="300"&gt; &lt;template slot-scope="scope"&gt; &lt;span style="margin-left: 10px"&gt;&#123;&#123; scope.row.address &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label="操作"&gt; &lt;template slot-scope="scope"&gt; &lt;el-button size="mini" @click="handleEdit(scope.$index, scope.row)"&gt;编辑&lt;/el-button&gt; &lt;el-button size="mini" type="danger" @click="handleDelete(scope.$index, scope.row)"&gt;删除&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt;&lt;el-dialog title="提示" :visible.sync="centerDialogVisible" width="30%" center&gt; &lt;el-form :model="temp" label-position="left" label-width="70px" style='width: 400px; margin-left:50px;'&gt; &lt;el-form-item label="日期" prop="date" &gt; &lt;el-date-picker v-model="temp.date" type="datetime" placeholder="请选择时间"&gt; &lt;/el-date-picker&gt; &lt;/el-form-item&gt; &lt;el-form-item label="名称" &gt; &lt;el-input v-model="temp.name"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="地址" &gt; &lt;el-input v-model="temp.address"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;span slot="footer" class="dialog-footer"&gt; &lt;el-button @click="centerDialogVisible = false"&gt;取 消&lt;/el-button&gt; &lt;el-button type="primary" @click="centerDialogVisible = false"&gt;确 定&lt;/el-button&gt; &lt;/span&gt;&lt;/el-dialog&gt;&lt;/div&gt; &lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; centerDialogVisible: false, tableData: [ &#123; date: "2016-05-02", name: "王小虎", address: "上海市普陀区金沙江路 1518 弄" &#125;, &#123; date: "2016-05-04", name: "王小虎", address: "上海市普陀区金沙江路 1517 弄" &#125;, &#123; date: "2016-05-01", name: "王小虎", address: "上海市普陀区金沙江路 1519 弄" &#125;, &#123; date: "2016-05-03", name: "王小虎", address: "上海市普陀区金沙江路 1516 弄" &#125; ], temp: &#123; date: new Date(), name: "", address: "" &#125; &#125;; &#125;, methods: &#123; handleEdit(index, row) &#123; // console.log(index, row); this.temp = Object.assign(&#123;&#125;, row); // copy obj this.temp.date = new Date(this.temp.date); this.centerDialogVisible = true; &#125;, handleDelete(index, row) &#123; console.log(index, row); &#125; &#125;&#125;;&lt;/script&gt; axios获取数据npm install axios –save1234567891011121314151617181920212223242526272829303132333435363738&lt;script&gt;import axios from "axios";export default &#123; data() &#123; return &#123; name: "表格", listQuery: &#123; page: 1, limit: 3, &#125;, newusers: [], total: null &#125;; &#125;, created() &#123; this.getUsers() &#125;, methods: &#123; getUsers() &#123; axios .get("http://localhost:8888/getList",&#123; params:&#123; pageNum:this.listQuery.page, pageSize:this.listQuery.limit &#125; &#125;) .then(response =&gt; &#123; console.log(response); this.newusers = response.data.list this.total=response.data.total &#125;) .catch(error =&gt; &#123; console.log("axios==" + error); &#125;); &#125; &#125;&#125;;&lt;/script&gt; springboot 集成PageHelper分页pom.xml123456&lt;!--pagehelper --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; UserController123456789101112131415161718192021 /** * @CrossOrigin是解决跨域问题 * @RestController注解相当于@ResponseBody ＋ @Controller合 * 在一起的作用。 */@RestController@CrossOriginpublic class UserController &#123; @Resource UserService userService; /** * 获取用户信息 * @param pageNum 当前页 * @param pageSize 当前页面展示数目 */ @RequestMapping(value = "/getList") public String getlist(int pageNum,int pageSize)&#123; Object users=userService.getUser(pageNum,pageSize); return JSON.toJSONString(users); &#125;&#125; UserServiceImpl实现类1234567891011121314151617181920@Servicepublic class UserServiceImpl implements UserService&#123; /** * * @Title: getUser * @Description: findByPage方法从数据库中获取所有user列表 * @param pageNum 当前页 * @param pageSize 当前页面展示数目 * @return */ @Override public PageInfo&lt;User&gt; getUser(int pageNum, int pageSize) &#123; //使用分页插件,核心代码就这一行 PageHelper.startPage(pageNum, pageSize); List&lt;User&gt; userList=userMapper.findByPage(); PageInfo result =new PageInfo(userList); return result; &#125;&#125; 结合以上三个技术就可以实现分页功能了。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 定时发送邮件]]></title>
    <url>%2F2018%2F06%2F06%2FSpringBoot-%E5%AE%9A%E6%97%B6%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[pom包配置1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 在application.properties中添加邮箱配置123456789#邮箱服务器地址spring.mail.host=smtp.163.com#用户名spring.mail.username=xxx@oo.com#密码spring.mail.password=xxyyooo spring.mail.default-encoding=UTF-8#以谁来发送邮件mail.fromMail.addr=xxx@oo.com MailService123456789public interface MailService &#123; void sendSimpleMail(String to, String subject, String content); void sendHtmlMail(String to, String subject, String content); void sendAttachmentsMail(String to, String subject, String content, String filePath); void sendInlineResourceMail(String to, String subject, String content, String rscPath, String rscId);&#125; MailServiceImpl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113@Componentpublic class MailServiceImpl implements MailService &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private JavaMailSender mailSender; @Value("$&#123;mail.fromMail.addr&#125;") private String from; /** * 发送文本邮件 * @param to * @param subject * @param content */ @Override public void sendSimpleMail(String to, String subject, String content) &#123; SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(from); message.setTo(to); message.setSubject(subject); message.setText(content); try &#123; mailSender.send(message); logger.info("简单邮件已经发送。"); &#125; catch (Exception e) &#123; logger.error("发送简单邮件时发生异常！", e); &#125; &#125; /** * 发送html邮件 * @param to * @param subject * @param content */ @Override public void sendHtmlMail(String to, String subject, String content) &#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; //true表示需要创建一个multipart message MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); mailSender.send(message); logger.info("html邮件发送成功"); &#125; catch (MessagingException e) &#123; logger.error("发送html邮件时发生异常！", e); &#125; &#125; /** * 发送带附件的邮件 * @param to * @param subject * @param content * @param filePath */ @Override public void sendAttachmentsMail(String to, String subject, String content, String filePath) &#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource file = new FileSystemResource(new File(filePath)); String fileName = filePath.substring(filePath.lastIndexOf(File.separator)); helper.addAttachment(fileName, file); //helper.addAttachment("test"+fileName, file); mailSender.send(message); logger.info("带附件的邮件已经发送。"); &#125; catch (MessagingException e) &#123; logger.error("发送带附件的邮件时发生异常！", e); &#125; &#125; /** * 发送正文中有静态资源（图片）的邮件 * @param to * @param subject * @param content * @param rscPath * @param rscId */ @Override public void sendInlineResourceMail(String to, String subject, String content, String rscPath, String rscId) &#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource res = new FileSystemResource(new File(rscPath)); helper.addInline(rscId, res); mailSender.send(message); logger.info("嵌入静态资源的邮件已经发送。"); &#125; catch (MessagingException e) &#123; logger.error("发送嵌入静态资源的邮件时发生异常！", e); &#125; &#125;&#125; 定时发送邮件123456789101112131415161718192021222324@Component@EnableScheduling // 启用定时任务public class SchedulUtil &#123; private final Logger logger = LoggerFactory.getLogger(getClass()); private static final SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss"); @Autowired private MailService mailService;// @Scheduled(cron = "0/5 * * * * ?") // 每20秒执行一次 @Scheduled(fixedRate = 6000) //每6秒 public void testSimpleMail() &#123; logger.info("现在时间：" + dateFormat.format(new Date())); mailService.sendSimpleMail("15180191339@139.com","test simple mail"," hello this is simple mail"); &#125; @Scheduled(fixedRate = 60000) //每分钟 public void sendInlineResourceMail() &#123; String rscId = "neo006"; String content="&lt;html&gt;&lt;body&gt;这是有图片的邮件：&lt;img src=\'cid:" + rscId + "\' &gt;&lt;/body&gt;&lt;/html&gt;"; String imgPath = "F:\\OuYangResume.github.io\\source\\_posts\\Vue优雅使用echarts\\bar.png"; mailService.sendInlineResourceMail("zhangwenguang123@qq.com", "主题：这是有图片的邮件", content, imgPath, rscId); &#125;&#125; 收到你的早安，晚安和gun。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue优雅使用echarts]]></title>
    <url>%2F2018%2F05%2F21%2FVue%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8echarts%2F</url>
    <content type="text"><![CDATA[npm 安装 EChartsnpm install echarts –save 引入 EChartsnpm上安装的ECharts会放在node_modules目录下。1.var echarts = require(&#39;echarts&#39;)2.import echarts from &#39;echarts&#39;通过以上两种方式得到 ECharts。 初始化echarts实例let myChart = echarts.init(dom,&#39;theme&#39;);dom是指一个具有高度的div,theme是指echarts主题。使用主题之前必须先引用。比如引用ECharts4中新出的黑色主题equire(&#39;echarts/theme/dark&#39;) 图表的配置项option和数据具体配置项就去官网查看api 生成图myChart.setOption(option) 提供一个vue的组件代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;template&gt; &lt;div :class=&quot;className&quot; id=&quot;bar&quot; :style=&quot;&#123;height:height,width:width&#125;&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;// import echarts from &quot;echarts&quot;;// require(&apos;echarts/theme/macarons&apos;) // echarts themeexport default &#123; props: &#123; className: &#123; type: String, default: &quot;chart&quot; &#125;, width: &#123; type: String, default: &quot;100%&quot; &#125;, height: &#123; type: String, default: &quot;300px&quot; &#125; &#125;, data() &#123; return &#123; chart: null &#125;; &#125;, methods: &#123; initChart() &#123; let echarts=require(&apos;echarts&apos;); this.chart = echarts.init(document.getElementById(&quot;bar&quot;),&apos;macarons&apos;); this.chart.setOption(&#123; title: &#123; text: &apos;输出与承受占比图&apos;, subtext: &apos;by ouyang&apos; &#125;, tooltip: &#123; trigger: &apos;axis&apos;, axisPointer: &#123; type: &apos;shadow&apos; &#125; &#125;, legend: &#123; data: [&apos;伤害&apos;, &apos;防御&apos;], x : &apos;right&apos;, y : &apos;top&apos;, &#125;, grid: &#123; left: &apos;3%&apos;, right: &apos;4%&apos;, bottom: &apos;3%&apos;, containLabel: true &#125;, xAxis: &#123; type: &apos;value&apos;, boundaryGap: [0, 0.01] &#125;, yAxis: &#123; type: &apos;category&apos;, data: [&apos;德玛&apos;,&apos;瑞文&apos;,&apos;亚索&apos;,&apos;盲僧&apos;,&apos;卡萨&apos;] &#125;, series: [ &#123; name: &apos;伤害&apos;, type: &apos;bar&apos;, data: [10000, 12000, 18000, 4399, 22000] &#125;, &#123; name: &apos;防御&apos;, type: &apos;bar&apos;, data: [19325, 9000, 8000, 16000, 6000] &#125; ]&#125;); &#125; &#125;, mounted()&#123; this.initChart() &#125;&#125;;&lt;/script&gt; 源码地址]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网]]></title>
    <url>%2F2018%2F05%2F14%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[肖申克里的人习惯被关在墙里，但他们至少知道有墙的存在。而你，被关在一个局域网，却自豪的说谁不会上网。其实你永远都没真正接触过真正的互联网。推荐两种科学上网的方式 LanternLantern是一款开源并且跨平台的翻墙工具。“蓝灯”是它的中文名。直接去github下载。傻瓜式安装。启动。下面那个地方真的有很多资源（来不及解释了，赶紧上飞机） SSR强力推荐这种方式。不限流量，而且还很稳定。去我的网盘下载就可以免费使用。密码：idnk使用方式更简单。下载，解压。找到你对应电脑类型的文件夹。双击飞机.exe就可以科学上网了。看片子$$俄罗斯小姐姐去了。 SSH送你也罢。sudo ssh root@39.108.100.163password:OuYangBo950924]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arcgis api实现一些常用的功能]]></title>
    <url>%2F2018%2F05%2F14%2Farcgis-api%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[GeometryService实现测量功能几何服务（GeometryService）可以用这个类实现测量直线的距离，形状的缓冲区分析，判断两个形状之间的关系（相交，相离等等），两个形状求交，对形状的裁剪的图形操作。 测量功能的具体代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="http://120.77.215.143:6012/arcgis_js_api/library/3.21/3.21/dijit/themes/tundra/tundra.css"/&gt; &lt;link rel="stylesheet" type="text/css" href="http://120.77.215.143:6012/arcgis_js_api/library/3.21/3.21/esri/css/esri.css"/&gt; &lt;script type="text/javascript" src="http://120.77.215.143:6012/arcgis_js_api/library/3.21/3.21/init.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="map" style="height: 700px;width: 100%"&gt;&lt;/div&gt;&lt;button id="JSarea"&gt;测量面积&lt;/button&gt;&lt;button id="JSline"&gt;测量距离&lt;/button&gt;&lt;button id="JSclear"&gt;清除&lt;/button&gt;&lt;/body&gt;&lt;script&gt; require([ "esri/map","extLayers/gaodeLayer","esri/layers/GraphicsLayer" ],function (Map,gaodeLayer,GraphicsLayer) &#123; var map=new Map("map",&#123; logo:false, center: [101.778112, 36.617042], zoom:13 &#125;); var gaodelayer=new gaodeLayer(); map.addLayer(gaodelayer); var disFun =false;//距离测量 var areaFun = false;//面积测量 var inputPoints = [];//存储生成点的集合 var totleDistance = 0.0;//总距离 require(["esri/toolbars/draw", "esri/symbols/SimpleLineSymbol","esri/symbols/SimpleFillSymbol", "esri/Color","esri/layers/GraphicsLayer","esri/graphic", "esri/symbols/Font", "esri/symbols/TextSymbol", "esri/symbols/SimpleMarkerSymbol", "esri/tasks/LengthsParameters", "esri/tasks/GeometryService","esri/geometry/Polyline", "esri/tasks/AreasAndLengthsParameters","esri/geometry/Point"], function (Draw,SimpleLineSymbol,SimpleFillSymbol,Color,GraphicsLayer, Graphic,Font,TextSymbol,SimpleMarkerSymbol,LengthsParameters,GeometryService, Polyline,AreasAndLengthsParameters,Point) &#123; var measureLayer=new GraphicsLayer(); map.addLayer(measureLayer); var toolbar = new Draw(map); var startFont = new Font('12px').setWeight(Font.WEIGHT_BOLD);//定义文字样式 //定义标记点样式 var makerSymbol=new SimpleMarkerSymbol(&#123; "color": [27,188,155,255], "size": 7, "type": "esriSMS", "style": "esriSMSCircle", "outline": &#123; "color": [52,73,94,255], "width": 2, "type": "esriSLS", "style": "esriSLSSolid" &#125; &#125;); var geometryService =new GeometryService("http://120.77.215.143:6080/arcgis/rest/services/Utilities/Geometry/GeometryServer"); $("#JSarea").on("click",function () &#123; areaFun=true; disFun=false; toolbar.activate(Draw.POLYGON);//画面 &#125;); $("#JSline").on("click",function () &#123; disFun=true; areaFun=false; toolbar.activate(Draw.POLYLINE);//绘制折线 &#125;); $("#JSclear").on("click",function () &#123; clearAction(); &#125;); map.on("click",function (evt) &#123; // console.log(evt); if(disFun)&#123; inputPoints.push(evt.mapPoint); var textSymbol; if(inputPoints.length ===1)&#123; textSymbol = new TextSymbol("起点",startFont,new Color([204,102,51])); textSymbol.setOffset(0,-20); measureLayer.add(new Graphic(evt.mapPoint,textSymbol)); &#125; if(inputPoints.length&gt;=2)&#123; // 设置距离测量的参数 var lengthParams = new LengthsParameters(); lengthParams.calculationType = 'preserveShape'; lengthParams.lengthUnit = GeometryService.UNIT_METER;//单位米 var p1 = inputPoints[inputPoints.length-2]; var p2 = inputPoints[inputPoints.length-1]; if(p1.x ===p2.x &amp;&amp;p1.y===p2.y)&#123; return; &#125; var polyline = new Polyline(map.spatialReference); polyline.addPath([p1,p2]); lengthParams.polylines=[polyline]; // 根据参数，动态的计算长度 geometryService.lengths(lengthParams,function (dis) &#123; console.log(dis); var _distance = dis.lengths[0]; totleDistance+=parseFloat(_distance);//计算总长度 var beetwentDistances = totleDistance.toFixed(2)+"米"; var tdistance = new TextSymbol(beetwentDistances,startFont,new Color([204,102,51])); tdistance.setOffset(40,-3); measureLayer.add(new Graphic(p2,tdistance)); &#125;); &#125; measureLayer.add(new Graphic(evt.mapPoint,makerSymbol));//添加样式点 &#125;else if(areaFun)&#123; measureLayer.add(new Graphic(evt.mapPoint,makerSymbol)); &#125; &#125;); //触发完成的事件 toolbar.on("draw-end",function (evt) &#123; // console.log(evt); if(disFun||areaFun)&#123; var geometry=evt.geometry; var symbol = null; switch(geometry.type)&#123; case "polyline": symbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([27,188,155,1]),2); break; case "polygon": symbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID,new Color([27,188,155,1]),2), new Color([255,255,0,0.25])); break; &#125; var graphic=new Graphic(geometry,symbol); measureLayer.add(graphic); if(disFun)&#123; inputPoints.splice(0,inputPoints.length);//删除数组中的所有元素 totleDistance =0.0;//清空距离值 disFun = false; &#125;else if(areaFun)&#123; var areasAndLengthParams = new AreasAndLengthsParameters(); //计算面积和周长的参数 areasAndLengthParams.lengthUnit = GeometryService.UNIT_METER;//设置距离单位 areasAndLengthParams.areaUnit=geometryService.UNIT_SQUARE_METERS; //平方米 areasAndLengthParams.calculationType="preserveShape"; geometryService.simplify([geometry],function (simplifiedGeometries) &#123; areasAndLengthParams.polygons=simplifiedGeometries; geometryService.areasAndLengths(areasAndLengthParams,function (result) &#123; // console.log(result); var font =new Font("14px",Font.STYLE_NORMAL,Font.VARIANT_NORMAL,Font.WEIGHT_BOLDER); var areaResult = new TextSymbol(parseFloat(result.areas[0]).toFixed(2) + "平方米",font,new Color([204,102,51])); var spoint = new Point(geometry.getExtent().getCenter().x,geometry.getExtent().getCenter().y,map.spatialReference); measureLayer.add(new Graphic(spoint,areaResult));//在地图上显示测量的面积 &#125;) &#125;); areaFun=false; &#125; &#125; toolbar.deactivate();//撤销地图绘制功能 &#125;); //清除功能 function clearAction() &#123; disFun=false; inputPoints.splice(0,inputPoints.length);//删除数组中的所有元素 totleDistance =0.0;//清空距离值 areaFun=false; toolbar.deactivate(); map.setMapCursor("default"); measureLayer.clear(); &#125; &#125;) &#125;)&lt;/script&gt;&lt;/html&gt; 效果图 动态轨迹原理也就是写一个定时器。一个点动态的沿着线从起点到线的终点。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;动态轨迹demo&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="http://120.77.215.143:6012/arcgis_js_api/library/3.21/3.21/dijit/themes/tundra/tundra.css"/&gt; &lt;link rel="stylesheet" type="text/css" href="http://120.77.215.143:6012/arcgis_js_api/library/3.21/3.21/esri/css/esri.css"/&gt; &lt;script type="text/javascript" src="http://120.77.215.143:6012/arcgis_js_api/library/3.21/3.21/init.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="map" style="height: 700px;width: 100%;"&gt;&lt;/div&gt;&lt;input type="button" id="openTool" value="开启" /&gt;&lt;/body&gt;&lt;script&gt; require(["esri/map", "extLayers/gaodeLayer","extLayers/TDTLayer", "esri/geometry/Polyline","esri/symbols/SimpleLineSymbol","esri/graphic","esri/layers/GraphicsLayer", "esri/geometry/Point","esri/symbols/PictureMarkerSymbol","esri/SpatialReference" ],function (Map,gaodeLayer,TDTLayer,Polyline,SimpleLineSymbol,Graphic,GraphicsLayer,Point,PictureMarkerSymbol,SpatialReference) &#123; var map=new Map("map",&#123; center:[112.6,30.5], zoom:6, slider:true, nav:false, logo:false &#125;); var gaodelayer=new gaodeLayer(); map.addLayer(gaodelayer); var graphicsLayer1=new GraphicsLayer();//线图层 map.addLayer(graphicsLayer1); var graphicsLayer=new GraphicsLayer();//动态点图层 map.addLayer(graphicsLayer); var path=&#123;"point":[[113.68,34.53], [115.58,34.55], [113.57,30.58],[115.53,30.6]]&#125;; var polyline = new Polyline(new SpatialReference(&#123;wkid:4326&#125;)); polyline.addPath(path.point); var sys=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH,new esri.Color([0,255,0]),3); var g=new Graphic(polyline,sys); graphicsLayer1.add(g); var point=new Point(path.point[0],new SpatialReference(&#123;wkid:4326&#125;)); var picBaseUrl = "https://static.arcgis.com/images/Symbols/Shapes/"; var blue = new PictureMarkerSymbol(picBaseUrl + "BluePin1LargeB.png", 30, 30).setOffset(0, 15); var graphic=new Graphic(point,blue); graphicsLayer.add(graphic); //根据坐标点进行移动 var points,moving; var startNum,endNum; document.getElementById("openTool").onclick=function()&#123; if(typeof(moving)!="undefined")&#123; clearInterval(moving); //清除移动 &#125; points = path.point; graphic.geometry.x = points[0][0]; graphic.geometry.y = points[0][1]; graphicsLayer.redraw(); move(0,1); &#125;; function move(start,end) &#123; var x1=points[start][0]; var y1=points[start][1]; var x2=points[end][0]; var y2=points[end][1]; var p=(y2-y1)/(x2-x1);//斜率 var v=0.01; //距离 moving=setInterval(function () &#123; startNum=start; endNum=end; //分别计算 x,y轴方向速度 if(Math.abs(p)==Number.POSITIVE_INFINITY)&#123;//p为无穷大 graphic.geometry.y+=v; &#125; else &#123; if (x2&lt;x1)&#123; graphic.geometry.x-=(1/Math.sqrt(1+p*p))*v; graphic.geometry.y-=(p/Math.sqrt(1+p*p))*v; &#125;else &#123; graphic.geometry.x+=(1/Math.sqrt(1+p*p))*v; graphic.geometry.y+=(p/Math.sqrt(1+p*p))*v; &#125; &#125; graphicsLayer.redraw(); if (Math.abs(graphic.geometry.x - x2) &lt;=0.01 &amp;&amp; Math.abs(graphic.geometry.y - y2) &lt;=0.01) &#123; clearInterval(moving); startNum=start++; endNum=end++; if (end &lt; points.length) move(start, end); &#125; &#125;,50); &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 聚类功能运用场景：从数据库中读取的点数据量很大或者小区域内点很密集影响展示的两种情况可以采取聚类的方式来得到解决。从arcgis api官方提供的聚类方法源码中，还不符合我的需求。1.当地图缩放到一定等级之后就不需要聚类了。2.点击聚类点不需要弹窗只需要单机一个点时才弹窗。所以修改了源码，并添加注释。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385define([ "dojo/_base/declare", "dojo/_base/array", "esri/Color", "dojo/_base/connect", "esri/SpatialReference", "esri/geometry/Point", "esri/graphic", "esri/symbols/SimpleMarkerSymbol", "esri/symbols/TextSymbol", "esri/dijit/PopupTemplate", "esri/layers/GraphicsLayer"], function ( declare, arrayUtils, Color, connect, SpatialReference, Point, Graphic, SimpleMarkerSymbol, TextSymbol, PopupTemplate, GraphicsLayer) &#123; return declare([GraphicsLayer], &#123; constructor: function (options) &#123; // options: // data: Object[] // Array of objects. Required. Object are required to have properties named x, y and attributes. The x and y coordinates have to be numbers that represent a points coordinates. // distance: Number? // Optional. The max number of pixels between points to group points in the same cluster. Default value is 50. // labelColor: String? // Optional. Hex string or array of rgba values used as the color for cluster labels. Default value is #fff (white). // labelOffset: String? // Optional. Number of pixels to shift a cluster label vertically. Defaults to -5 to align labels with circle symbols. Does not work in IE. // resolution: Number // Required. Width of a pixel in map coordinates. Example of how to calculate: // map.extent.getWidth() / map.width // showSingles: Boolean? // Optional. Whether or graphics should be displayed when a cluster graphic is clicked. Default is true. // singleSymbol: MarkerSymbol? // Marker Symbol (picture or simple). Optional. Symbol to use for graphics that represent single points. Default is a small gray SimpleMarkerSymbol. // singleTemplate: PopupTemplate? // PopupTemplate&lt;/a&gt;. Optional. Popup template used to format attributes for graphics that represent single points. Default shows all attributes as "attribute = value" (not recommended). // maxSingles: Number? // Optional. Threshold for whether or not to show graphics for points in a cluster. Default is 1000. // webmap: Boolean? // Optional. Whether or not the map is from an ArcGIS.com webmap. Default is false. // spatialReference: SpatialReference? // Optional. Spatial reference for all graphics in the layer. This has to match the spatial reference of the map. Default is 102100. Omit this if the map uses basemaps in web mercator. this._clusterTolerance = options.distance || 50; this._clusterData = options.data || []; this._clusters = []; this._clusterLabelColor = options.labelColor || "#000"; // labelOffset can be zero so handle it differently this._clusterLabelOffset = (options.hasOwnProperty("labelOffset")) ? options.labelOffset : -5; // graphics that represent a single point this._singles = []; // populated when a graphic is clicked this._showSingles = options.hasOwnProperty("showSingles") ? options.showSingles : true; // symbol for single graphics var SMS = SimpleMarkerSymbol; this._singleSym = options.singleSymbol || new SMS("circle", 6, null, new Color("#888")); this._singleTemplate = options.singleTemplate || new PopupTemplate(&#123; "title": "", "description": "&#123;*&#125;" &#125;); this._maxSingles = options.maxSingles || 1000; this._webmap = options.hasOwnProperty("webmap") ? options.webmap : false; this._sr = options.spatialReference || new SpatialReference(&#123; "wkid": 102100 &#125;); this._zoomEnd = null; //新增属性 this._maxZoom = options.maxZoom || 12; this._map = null; &#125;, // override esri/layers/GraphicsLayer methods 重写setMap方法 _setMap: function (map, surface) &#123; // calculate and set the initial resolution 计算和设置初始分辨率 this._clusterResolution = map.extent.getWidth() / map.width; // probably a bad default... this._map = map;//将map设置为全局变量 this._clusterGraphics();//聚类 // connect to onZoomEnd so data is re-clustered when zoom level changes当缩放级别改变时数据会重新聚集。 this._zoomEnd = connect.connect(map, "onZoomEnd", this, function () &#123; // update resolution this._clusterResolution = this._map.extent.getWidth() / this._map.width; this.clear();//清除 this._clusterGraphics(); //重新聚类 &#125;); // GraphicsLayer will add its own listener here var div = this.inherited(arguments); return div; &#125;, _unsetMap: function () &#123; this.inherited(arguments); connect.disconnect(this._zoomEnd); &#125;, // public ClusterLayer methods add: function (p) &#123; // Summary: The argument is a data point to be added to an existing cluster. If the data point falls within an existing cluster, it is added to that cluster and the cluster's label is updated. If the new point does not fall within an existing cluster, a new cluster is created. // // if passed a graphic, use the GraphicsLayer's add method if (p.declaredClass) &#123; this.inherited(arguments); return; &#125; // add the new data to _clusterData so that it's included in clusters // when the map level changes this._clusterData.push(p); var clustered = false; // look for an existing cluster for the new point for (var i = 0; i &lt; this._clusters.length; i++) &#123; var c = this._clusters[i]; if (this._clusterTest(p, c)) &#123; // add the point to an existing cluster this._clusterAddPoint(p, c); // update the cluster's geometry this._updateClusterGeometry(c); // update the label this._updateLabel(c); clustered = true; break; &#125; &#125; if (!clustered) &#123; this._clusterCreate(p); p.attributes.clusterCount = 1; this._showCluster(p); &#125; &#125;, clear: function () &#123; // Summary: Remove all clusters and data points. this.inherited(arguments); this._clusters.length = 0; &#125;, clearSingles: function (singles) &#123; // Summary: Remove graphics that represent individual data points. var s = singles || this._singles; arrayUtils.forEach(s, function (g) &#123; this.remove(g); &#125;, this); this._singles.length = 0; &#125;, onClick: function (e) &#123; // remove any previously showing single features this.clearSingles(this._singles); // find single graphics that make up the cluster that was clicked // would be nice to use filter but performance tanks with large arrays in IE var singles = []; for (var i = 0, il = this._clusterData.length; i &lt; il; i++) &#123; if (e.graphic.attributes.clusterId == this._clusterData[i].attributes.clusterId) &#123; singles.push(this._clusterData[i]); &#125; &#125; //如果聚类点的个数大于0 if (singles.length &gt; this._maxSingles || singles.length &gt; 1) &#123; // alert("Sorry, that cluster contains more than " + this._maxSingles + " points. Zoom in for more detail."); var level = this._map.getLevel() + 2 &gt;= 17 ? 17 : this._map.getLevel() + 2; this._map.setZoom(level); this._map.centerAt(e.graphic.geometry); return; &#125; else &#123; // stop the click from bubbling to the map e.stopPropagation(); //阻止map的冒泡事件 this._map.infoWindow.show(e.graphic.geometry); this._addSingles(singles); &#125; &#125;, // internal methods 内部方法 _clusterGraphics: function () &#123; // first time through, loop through the points 遍历所有数据 for (var j = 0, jl = this._clusterData.length; j &lt; jl; j++) &#123; // see if the current feature should be added to a cluster var point = this._clusterData[j]; //状态 var clustered = false; //遍历聚类数据 for (var i = 0; i &lt; this._clusters.length; i++) &#123; var c = this._clusters[i]; //如果为true,就push到同一个数组中 if (this._clusterTest(point, c)) &#123; this._clusterAddPoint(point, c); clustered = true; break; &#125; &#125; if (!clustered) &#123; //如果不为真，将点push到要聚类的数组中 this._clusterCreate(point); &#125; &#125; this._showAllClusters(); &#125;, //判断点是否需要聚类 _clusterTest: function (p, cluster) &#123; //计算距离 var distance = ( Math.sqrt( Math.pow((cluster.x - p.x), 2) + Math.pow((cluster.y - p.y), 2) ) / this._clusterResolution ); var _flag = (distance &lt;= this._clusterTolerance); var _level = this._map.getZoom(); if (_level &gt;= this._maxZoom) _flag = false; return _flag; &#125;, // points passed to clusterAddPoint should be included // in an existing cluster // also give the point an attribute called clusterId // that corresponds to its cluster //将point加到cluster数组中 _clusterAddPoint: function (p, cluster) &#123; // average in the new point to the cluster geometry var count, x, y; count = cluster.attributes.clusterCount; //重新计算cluster对象的x,y,总数 x = (p.x + (cluster.x * count)) / (count + 1); y = (p.y + (cluster.y * count)) / (count + 1); cluster.x = x; cluster.y = y; // build an extent that includes all points in a cluster // extents are for debug/testing only...not used by the layer //修改cluster的四至 if (p.x &lt; cluster.attributes.extent[0]) &#123; cluster.attributes.extent[0] = p.x; &#125; else if (p.x &gt; cluster.attributes.extent[2]) &#123; cluster.attributes.extent[2] = p.x; &#125; if (p.y &lt; cluster.attributes.extent[1]) &#123; cluster.attributes.extent[1] = p.y; &#125; else if (p.y &gt; cluster.attributes.extent[3]) &#123; cluster.attributes.extent[3] = p.y; &#125; // increment the count 增加++ cluster.attributes.clusterCount++; // 判断对象是否含有指定的属性的 if (!p.hasOwnProperty("attributes")) &#123; p.attributes = &#123;&#125;; &#125; // give the graphic a cluster id 将p的clusterId设置为cluster的id p.attributes.clusterId = cluster.attributes.clusterId; &#125;, // point passed to clusterCreate isn't within the // clustering distance specified for the layer so // create a new cluster for it //创建cluster对象 _clusterCreate: function (p) &#123; var clusterId = this._clusters.length + 1; // p.attributes might be undefined 如果没有定义attributes if (!p.attributes) &#123; p.attributes = &#123;&#125;; &#125; p.attributes.clusterId = clusterId; // 创建cluster对象 var cluster = &#123; "x": p.x, "y": p.y, "attributes": &#123; "clusterCount": 1, "clusterId": clusterId, "extent": [p.x, p.y, p.x, p.y] &#125; &#125;; this._clusters.push(cluster);//push到聚类数组中 &#125;, //显示聚类数组 _showAllClusters: function () &#123; for (var i = 0, il = this._clusters.length; i &lt; il; i++) &#123; var c = this._clusters[i]; this._showCluster(c); &#125; &#125;, _showCluster: function (c) &#123; var point = new Point(c.x, c.y, this._sr); this.add( new Graphic( point, null, c.attributes ) ); // code below is used to not label clusters with a single point //如果聚类数组中的cluster对象的clusterCount为1，就不需要加label if (c.attributes.clusterCount == 1) &#123; return; &#125; // show number of points in the cluster //显示聚类点数 var label = new TextSymbol(c.attributes.clusterCount.toString()) .setColor(new Color(this._clusterLabelColor)) .setOffset(0, this._clusterLabelOffset); this.add( new Graphic( point, label, c.attributes ) ); &#125;, _addSingles: function (singles) &#123; // add single graphics to the map arrayUtils.forEach(singles, function (p) &#123; var g = new Graphic( new Point(p.x, p.y, this._sr), this._singleSym, p.attributes, this._singleTemplate ); this._singles.push(g); if (this._showSingles) &#123; this.add(g); &#125; &#125;, this); this._map.infoWindow.setFeatures(this._singles); &#125;, //add方法中修改cluster的x,y _updateClusterGeometry: function (c) &#123; // find the cluster graphic 根据clusterId在聚类数组中找到这个cluster var cg = arrayUtils.filter(this.graphics, function (g) &#123; return !g.symbol &amp;&amp; g.attributes.clusterId == c.attributes.clusterId; &#125;); //修改这个cluster的x,y if (cg.length == 1) &#123; cg[0].geometry.update(c.x, c.y); &#125; else &#123; console.log("在聚类数组中没有找到这个对象: ", cg); &#125; &#125;, //add方法中修改cluster的样式 _updateLabel: function (c) &#123; // find the existing label var label = arrayUtils.filter(this.graphics, function (g) &#123; return g.symbol &amp;&amp; g.symbol.declaredClass == "esri.symbol.TextSymbol" &amp;&amp; g.attributes.clusterId == c.attributes.clusterId; &#125;); if (label.length == 1) &#123; // console.log("update label...found: ", label); this.remove(label[0]); var newLabel = new TextSymbol(c.attributes.clusterCount) .setColor(new Color(this._clusterLabelColor)) .setOffset(0, this._clusterLabelOffset); this.add( new Graphic( new Point(c.x, c.y, this._sr), newLabel, c.attributes ) ); &#125; else &#123; console.log("在聚类数组中没有找到这个对象: ", label); &#125; &#125;, // debug only...never called by the layer _clusterMeta: function () &#123; // print total number of features console.log("Total: ", this._clusterData.length); // add up counts and print it var count = 0; arrayUtils.forEach(this._clusters, function (c) &#123; count += c.attributes.clusterCount; &#125;); console.log("In clusters: ", count); &#125; &#125;); &#125;); 在github上放有具体应用。]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用mybatis-generator自动生成代码]]></title>
    <url>%2F2018%2F04%2F12%2F%E5%88%A9%E7%94%A8mybatis-generator%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[逆向工程常用的逆向工程方式是通过数据库的表生成代码（包括mapper.xml、dao.java、bean.java）。 配置Maven的pom.xml文件 12345678910111213141516171819&lt;!-- MyBatis代码生成 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;configurationFile&gt;generatorConfig.xml&lt;/configurationFile&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;!-- 数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.30&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; 编写generatorConfig.xml文件 可以看到pom.xml文件中配置了generatorConfig.xml的所在位置 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;context id="MySQLTables" targetRuntime="MyBatis3"&gt; &lt;!--关闭注释 --&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接信息 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://&#123;&#123;ip&#125;&#125;:3306/database?useUnicode=true&amp;amp;characterEncoding=utf-8" userId="root" password="&#123;&#123;密码&#125;&#125;"&gt; &lt;/jdbcConnection&gt; &lt;!--生成的model 包路径 --&gt; &lt;javaModelGenerator targetPackage="cn.edu.whu.bean" targetProject="F:\IdeaWork\SSM\src\main\java"&gt; &lt;property name="enableSubPackages" value="ture"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!--生成xml mapper文件 路径 --&gt; &lt;sqlMapGenerator targetPackage="mybatis" targetProject="F:\IdeaWork\SSM\src\main\resources"&gt; &lt;property name="enableSubPackages" value="ture"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成的Dao接口 的包路径 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="cn.edu.whu.dao" targetProject="F:\IdeaWork\SSM\src\main\java"&gt; &lt;property name="enableSubPackages" value="ture"/&gt; &lt;/javaClientGenerator&gt; &lt;!--对应数据库表名 --&gt; &lt;table tableName="access"&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 绝大部分出错都是路径问题，上面也可以同时生成多个表。 执行generatorConfig.xml生成代码图中标红的代码即是生成的代码。自动生成的代码也只有简单的增删改查。业务逻辑代码还需要自己敲咯。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识图谱]]></title>
    <url>%2F2018%2F04%2F11%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%2F</url>
    <content type="text"><![CDATA[深拷贝和浅拷贝浅复制 —-只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。 深复制 —-在计算机中开辟了一块新的内存地址用于存放复制的对象。浅拷贝实例12345678910111213//此递归方法不包含数组对象var obj = &#123; a:1, arr: [2,3] &#125;;var shallowObj = shallowCopy(obj);function shallowCopy(src) &#123; var newobj = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; newobj[prop] = src[prop]; &#125; &#125; return newobj;&#125; 导致的结果就是：shallowObj.arr[1] = 5;console.log(obj.arr[1]); // 5深拷贝实例1234567891011121314151617181920212223242526272829var obj = &#123; a:1, arr: [1,2]， nation : '中国', birthplaces:['北京','上海','广州']&#125;;var obj2 = &#123;name:'杨'&#125;;obj2 = deepCopy(obj,obj2);console.log(obj2);//深复制，要想达到深复制就需要用递归function deepCopy(o,c)&#123; var c = c || &#123;&#125;； for(var i in o)&#123; if(typeof o[i] === 'object')&#123; //要考虑深复制问题了 if(o[i].constructor === Array)&#123; //这是数组 c[i] =[]； &#125;else&#123; //这是对象 c[i] = &#123;&#125;； &#125; deepCopy(o[i],c[i])； &#125;else&#123; c[i] = o[i]； &#125; &#125; return c &#125; 线程与进程进程：一个程序是静态的，通常是存放在外存中的。而当程序被调入内存中运行后，就成了进程。线程：一个进程内部可能包含了很多顺序执行流，每个顺序执行流就是一个线程。多线程就是有多条顺序执行流“同时”[并发]执行，且它们之间互不干扰。两者的区别：一个程序至少有一个进程,一个进程至少有一个线程。多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。来实现进程的调度和管理以及资源分配。 阻塞与非阻塞阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。函数只有在得到结果之后才会返回。非阻塞指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。 同步与异步同步:所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。异步: 异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。消息通知: 异步的概念和同步相对。当一个同步调用发出后，调用者要一直等待返回消息（结果）通知后，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果）。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。 http请求http请求包含有请求头，请求行，请求正文。1234567891011axios(&#123; method: 'post', url: '/user/12345', headers:&#123; 'Content-Type':'application/x-www-form-urlencoded' &#125;, data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;); method和url就是这个请求的请求行（这里是请求行部分信息，其实请求行还包括http协议的版本等信息）。headers中的属性就是请求头，里面的属性，全部包含在请求的header里面，是服务端获取客户端版本，缓存等信息的一个途径。data对应的就是请求正文，也就是平常所说的参数。 响应在请求发出去，并且响应已经回来的时候，就时候信息可分为响应行，响应头，响应正文。响应行:返回请求的http协议及版本，状态码，请求状态等描述信息。响应头:响应头和请求头格式一致，返回版本，缓存等信息。响应正文:也就是日常开发需要用到的数据。 常见的HTTP相应状态码200：请求成功400：参数错误403：拒绝或者禁止访问（无权限访问）404：地址不存在405：客户端请求中的方法被禁止（一般是请求方式错误）500：服务器报错502：请求超时，无效网关503：服务器超载或者维护，无法响应 httpsHTTPS=数据加密+网站认证+完整性验证+HTTP 响应式和自适应响应式：一个网页，根据屏幕的宽度的改变而展示不同的效果，代码基本是两套以上。在所有屏幕上都展示很好的效果，但是设计，开发成本高。 自适应：一个网页，根据屏幕宽度的改变而改变。代码只有一套。在个别的屏幕上，排版这个比较丑，但是设计，开发成本低。 盒子模型1.IE5盒子width = 内容 + border + padding盒子占据的宽度 = margin2+width2.W3C盒子width = 内容盒子占据的宽度 = margin2+border2+padding2+width3.设置浏览器去遵循w3c标准只需要在网页的顶部加上DOCTYPE声明即可另外注意 !important 的使用 p{ color:red !important; color:blue; }当不加!important;的时候，后者覆盖前者，当加上之后说明第一个,样式优先级更高，采用前者，但是Ie6不支持!important; 块级元素和内联元素在标准文档流里面，块级元素具有以下特点： ①总是在新行上开始，占据一整行；②高度，行高以及外边距和内边距都可控制；③宽带始终是与浏览器宽度一样，与内容无关；④它可以容纳内联元素和其他块元素。 行内元素的特点： ①和其他元素都在一行上；②高，行高及外边距和内边距部分可改变；③宽度只与内容有关；④行内元素只能容纳文本或者其他行内元素。不可以设置宽高，其宽度随着内容增加，高度随字体大小而改变，内联元素可以设置外边界，但是外边界不对上下起作用，只能对左右起作用，也可以设置内边界，但是内边界在ie6中不对上下起作用，只能对左右起作用display:block – 显示为块级元素display:inline – 显示为内联元素dipslay:inline-block – 显示为内联块元素，表现为同行显示并可修改宽高内外边距等属性. 模块化编程①AMD（异步模块定义） requirejs异步加载，浏览器不会失去响应它指定的回调函数，只有前面的模块都加载完成后，才会运行，解决了依赖性问题②CMD（通用模块定义） seajs模块定义方式和模块加载时机处理不同③区别：AMD依赖前置，在定义模块的时候就要声明其依赖的模块；CMD就近依赖，只有在用到哪个模块的时候再去require； 一个页面从URL到加载显示完成，都发生了什么？1、首先，在浏览器地址栏中输入url2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。3、在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。5、握手成功后，浏览器向服务器发送http请求，请求数据包。6、服务器处理收到的请求，将数据返回至浏览器7、浏览器收到HTTP响应8、读取页面内容，浏览器渲染，解析html源码9、生成Dom树、解析css样式、js交互10、客户端和服务器交互11、ajax查询 前端安全XSS：跨站脚本攻击，注入攻击的一种。攻击者利用应用程序的动态展示功能，在HTML页面中嵌入恶意代码。当用户浏览该页时，这些嵌入在html的恶意代码就会被执行，用户浏览器被攻击者控制。CSRF:是跨站请求伪造。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。其实就是攻击者盗用了你的身份，以你的名义发送恶意请求。 MVVMWeb 前端一种非常流行的开发模式，利用 MVVM 可以使我们的代码更专注于处理业务逻辑而不是去关心 DOM 操作。 Vue组件data为什么必须是函数如果不用function return 每个组件的data都是内存的同一个地址，那一个数据改变其他也改变了，这当然就不是我们想要的。用function return 其实就相当于申明了新的变量，相互独立，自然就不会有这样的问题。 javascript有哪几种数据类型六种基本数据类型undefinednullstringbooleannumbersymbol(ES6)一种引用类型Object 事件冒泡、事件捕捉、事件委托事件捕获:从document到触发事件的那个节点，即自上而下的去触发事件。事件冒泡:刚好相反，是从触发事件的那个节点一直到document，是自下而上的去触发事件。绑定事件方法（addEventListener）的第三个参数，就是控制事件触发顺序是否为事件捕获。true,事件捕获；false,事件冒泡。默认false,即事件冒泡,所以当你对一个dom节点触发事件时，若外层的节点也设置了相应的事件函数，就会使外层的节点也触发自己的事件函数。事件委托:当有多个类似的元素需要绑定事件时，一个一个去绑定即浪费时间，又不利于性能，这时候就可以用到事件委托，给他们的一个共同父级元素添加一个事件函数去处理他们所有的事件阻止事件委托和冒泡：在事件函数中执行event.stopPropagation() 原型链构造函数创建一个对象：123456function Person() &#123;&#125;var person = new Person();person.name = 'Kevin';console.log(person.name) // Kevin prototype:每个函数都有一个 prototype 属性。prototype显式原型属性（只有函数有prototype,对象是没有的。）__proto__ :这是每一个JavaScript对象(除了 null )都具有的一个属性，叫proto隐式原型属性，这个属性会指向该对象的原型。constructor:每个原型都有一个 constructor 属性指向关联的构造函数。Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。这里new关键字起到了以下几个作用： var obj = {}; obj.proto = Person.prototype; Person.call(obj); 1.创建了一个空对象obj。 2.将这个空对象的隐式原型proto指向构造函数的显示原型prototype；如例，是将空对象的proto成员指向了Person函数对象prototype成员对象；从而形成了所谓的原型链：下图中的蓝色线。 3.将构造函数的this指向实例（即空对象），并调用Person函数； call、aplly、bind之间的区别相同点：1.都是用来改变函数的this对象的指向的。2.第一个参数都是this要指向的对象。1234567891011121314151617var xw=&#123; name: "小王", gender: "男", age: 24, say: function()&#123; alert(this.name+" , "+this.gender+" ,今年"+this.age); &#125;, say1: function(school,grade)&#123; alert(this.name+" , "+this.gender+" ,今年"+this.age+" ,在"+school+"上"+grade); &#125;&#125;var xh=&#123; name: "小红", gender: "女", age: 18&#125;xw.say(); xw.say1.call(xh,&quot;实验小学&quot;,&quot;六年级&quot;);xw.say.apply(xh,[&quot;实验小学&quot;,&quot;六年级&quot;]);xw.say.bind(xh,&quot;实验小学&quot;,&quot;六年级&quot;)();三者的区别应该可以从上面三者调用方式可以看出来了。 sessionStorage、localStorage和cookie共同点：都是保存在浏览器端、且同源的。不同点：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。存储大小限制也不同，cookie数据不能超过4K。数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭。作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。 html5离线储存怎么使用，工作原理能不能解释一下？HTML5的离线存储是基于一个新建的.appcache文件的，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 javascript中实现继承123456789101112131415161718// 父类 function Persion(name,age)&#123; this.name = name; this.age = age; &#125; // 父类的原型对象属性继承 Persion.prototype.id = 10; // 子类 function Boy(name,age,sex)&#123; //call apply 借用构造函数的方式继承 Persion.call(this,name,age); this.sex = sex; &#125; // 原型继承实现 参数为空 代表 父类的实例和父类的原型对象的关系了 Boy.prototype = new Persion(); var b = new Boy('c5',27,'男'); alert(b.name)// c5 alert(b.id)//10 javascript的执行机制首先javascript是一门单线程语言。按照语句出现的顺序执行的. 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的Event Loop(事件循环)。 js异步又细分为：macro-task(宏任务)：包括整体代码script，setTimeout，setIntervalmicro-task(微任务)：Promise.then()，process.nextTick 事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回调函数，然后再从宏任务的queue上拿宏任务的回调函数。 for in 和for of的区别for in更适合遍历对象。for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。 12345678var arrs = [1,2,3,4.5]; for(let x in arrs)&#123; console.log(x) // 输出结果的0,1,2,3&#125; for(let x of arrs)&#123; console.log(x); //输出结果是1，2，3，4.5&#125; for..of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合.但是不能遍历对象,因为没有迭代器对象.与forEach()不同的是，它可以正确响应break、continue和return语句。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员应该知道的一些东西]]></title>
    <url>%2F2018%2F04%2F10%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[数据结构 什么是队列、栈、链表数组、链表、堆栈和队列是最基本的数据结构，队列就是一种先进先出的逻辑结构，栈是一种先进后出的逻辑结构。 什么是树（平衡树,排序树,B树,B+树,R树,红黑树）、堆（大根堆、小根堆）、图（有向图、无向图、拓扑） 栈通常采用的两种存储结构链接存储：链栈带有头指针或头结点的单循环链表。顺序存储：数组实现。 两个栈实现队列，和两个队列实现栈链接答案 排序算法冒泡排序冒泡排序是一种简单的排序方法，它的基本思想是：通过相邻两个元素之间比较和交换，使较大的元素逐渐从前面移向后面（升序），就像水底下的气泡一样逐渐向上冒泡，所以被称为“冒泡”排序。冒泡排序的最坏时间复杂度为O(n2)，平均时间复杂度为O(n2)。12345678910111213141516171819/** * 排序算法 * @param list */ public static void bubbleSort(int[] list)&#123; int temp; // 做多少轮排序（最多length-1轮） for (int i=0;i &lt;list.length-1;i++)&#123; // 每一轮比较多少个 for (int j=0;j&lt;list.length-1-i;j++)&#123; if (list[j]&gt;list[j+1])&#123; //交换 temp = list[j]; list[j] = list[j+1]; list [j+1]=temp; &#125; &#125; &#125; &#125; 快速排序快速排序的基本思想是：通过一轮排序将待排序元素分割成独立的两部分， 其中一部分的所有元素均比另一部分的所有元素小，然后分别对这两部分的元素继续进行快速排序，以此达到整个序列变成有序序列。快速排序的最坏时间复杂度为O(n2)，平均时间复杂度为O(n*log2n)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 快速排序算法 */ public static void quickSort(int[] list, int left, int right) &#123; if (left &lt; right) &#123; // 分割数组，找到分割点 int point = partition(list, left, right); // 递归调用，对左子数组进行快速排序 quickSort(list, left, point - 1); // 递归调用，对右子数组进行快速排序 quickSort(list, point + 1, right); &#125; &#125; /** * 分割数组，找到分割点 */ public static int partition(int[] list, int left, int right) &#123; // 用数组的第一个元素作为基准数 int first = list[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; list[right] &gt;= first) &#123; right--; &#125; // 交换 swap(list, left, right); while (left &lt; right &amp;&amp; list[left] &lt;= first) &#123; left++; &#125; // 交换 swap(list, left, right); &#125; // 返回分割点所在的位置 return left; &#125; /** * 交换数组中两个位置的元素 */ public static void swap(int[] list, int left, int right) &#123; int temp; if (list != null &amp;&amp; list.length &gt; 0) &#123; temp = list[left]; list[left] = list[right]; list[right] = temp; &#125; &#125; 直接选择排序直接选择排序(Straight Select Sort) 是一种简单的排序方法，它的基本思想是：通过length-1 趟元素之间的比较，从length-i+1个元素中选出最小的元素，并和第i个元素交换位置。直接选择排序的最坏时间复杂度为O(n2)，平均时间复杂度为O(n2) 12345678910111213141516171819202122232425262728293031/** * 直接选择排序算法 */ public static void selectionSort(int[] list) &#123; // 要遍历的次数（length-1次） for (int i = 0; i &lt; list.length - 1; i++) &#123; // 将当前下标定义为最小值下标 int min = i; // 遍历min后面的数据 for (int j = i + 1; j &lt;= list.length - 1; j++) &#123; // 如果有小于当前最小值的元素，将它的下标赋值给min if (list[j] &lt; list[min]) &#123; min = j; &#125; &#125; // 如果min不等于i，说明找到真正的最小值 if (min != i) &#123; swap(list, min, i); &#125; &#125; &#125; /** * 交换数组中两个位置的元素 */ public static void swap(int[] list, int min, int i) &#123; int temp = list[min]; list[min] = list[i]; list[i] = temp; &#125; 堆排序堆排序(Heap Sort) 利用堆（一般为大根堆）进行排序的方法。它的基本思想是：将待排序的元素构造成一个大根堆。此时，整个序列的最大值就是堆顶的根节点。将它移走（其实就是将它与数组的末尾元素进行交换，此时末尾元素就是最大值），然后将剩余的length-1 个元素重新构造成一个大根堆，这样就会得到length个元素中的次大值。如此反复执行，便能得到一个有序的序列。 堆是具有下列性质的完全二叉树：每个节点的值都大于或等于其左右孩子节点的值，称为大根堆；每个节点的值都小于或等于其左右孩子节点的值，称为小根堆。 堆排序的最坏时间复杂度为O(nlog2n)，平均时间复杂度为O(nlog2n)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 堆排序算法 */ public static void heapSort(int[] list) &#123; // 将无序堆构造成一个大根堆，大根堆有length/2个父节点 for (int i = list.length / 2 - 1; i &gt;= 0; i--) &#123; headAdjust(list, i, list.length); &#125; // 逐步将每个最大值的根节点与末尾元素交换，并且再调整其为大根堆 for (int i = list.length - 1; i &gt; 0; i--) &#123; // 将堆顶节点和当前未经排序的子序列的最后一个元素交换位置 swap(list, 0, i); headAdjust(list, 0, i); &#125; &#125; /** * 构造大根堆 */ public static void headAdjust(int[] list, int parent, int length) &#123; // 保存当前父节点 int temp = list[parent]; // 得到左孩子节点 int leftChild = 2 * parent + 1; while (leftChild &lt; length) &#123; // 如果parent有右孩子，则要判断左孩子是否小于右孩子 if (leftChild + 1 &lt; length &amp;&amp; list[leftChild] &lt; list[leftChild + 1]) &#123; leftChild++; &#125; // 父亲节点大于子节点，就不用做交换 if (temp &gt;= list[leftChild]) &#123; break; &#125; // 将较大子节点的值赋给父亲节点 list[parent] = list[leftChild]; // 然后将子节点做为父亲节点 parent = leftChild; // 找到该父亲节点较小的左孩子节点 leftChild = 2 * parent + 1; &#125; // 最后将temp值赋给较大的子节点，以形成两值交换 list[parent] = temp; &#125; /** * 交换数组中两个位置的元素 */ public static void swap(int[] list, int top, int last) &#123; int temp = list[top]; list[top] = list[last]; list[last] = temp; &#125; 直接插入排序直接插入排序的基本思想是：每次从无序序列中取出第一个元素插入到已经排好序的有序序列中，从而得到一个新的，数量加1的有序序列。1234567891011121314151617/** * 直接插入排序算法 */ public static void insertSort(int[] list) &#123; // 从无序序列中取出第一个元素 (注意无序序列是从第二个元素开始的) for (int i = 1; i &lt; list.length; i++) &#123; int temp = list[i]; int j; // 遍历有序序列 // 如果有序序列中的元素比临时元素大，则将有序序列中比临时元素大的元素依次后移 for (j = i - 1; j &gt;= 0 &amp;&amp; list[j] &gt; temp; j--) &#123; list[j + 1] = list[j]; &#125; // 将临时元素插入到腾出的位置中 list[j + 1] = temp; &#125; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue结合leaflet实现地图的常用功能]]></title>
    <url>%2F2018%2F04%2F03%2Fvue%E7%BB%93%E5%90%88leaflet%E5%AE%9E%E7%8E%B0%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[用vue-cli搭建项目并加载地图搭建项目参考Vue官网就行。本想着一步一步开始，由于天气热。今天有丶累，不想艹你。总之现在不想写。先附上我的仓库源码地址和效果图吧 自定义Marker图标 聚类效果 热力图]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>GIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北纬30°，武汉的每天不一样]]></title>
    <url>%2F2018%2F03%2F27%2F%E5%8C%97%E7%BA%AC30%C2%B0%EF%BC%8C%E6%AD%A6%E6%B1%89%E7%9A%84%E6%AF%8F%E5%A4%A9%E4%B8%8D%E4%B8%80%E6%A0%B7%2F</url>
    <content type="text"><![CDATA[毕业之后独自来到武汉，从什么都不知道到到什么都不懂。人懒惰了，变得不那么喜欢运动了。或许就是身边没有学校那种一叫就走的朋友吧。在此期间找了一个小女朋友。别人说找女朋友最厉害的一招是欲擒故纵。而我认为的是在她最需要照顾的时候，选择不离开。放一张为数不多的合影吧。 二〇一八年三月十八日 来武汉这么久了，还没有好好逛过这个城市。最近樱花盛开约上好友去了有名武大樱花园。晚上吃了油焖‘小’虾（季节不对T﹏T），吃什么不重要，和谁一起才是重点。 二〇一八年三月二十五日突然写一个城市，还真有很多事情，又不知如何下笔。矫情]]></content>
      <categories>
        <category>随笔生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OGC标准]]></title>
    <url>%2F2018%2F03%2F23%2FOGC%E6%A0%87%E5%87%86%2F</url>
    <content type="text"><![CDATA[一：OGC与OGC标准制定与空间信息，基于位置服务相关的标准文档，按照这些文档开放服务的接口，空间数据存储的编码，空间操作的方法。OGC官网 二：SFS -简单的要素标准 几何对象模型几何对象（点，线，面和多点，多线，多面）和对象的一系列操作。 WKT描述几何对象WKT可以通过文本来描述几何对象。12345Point(10 10) //点LineString(10 10,20 20,30 40) //3个节点的线Polygon((10 10,10 20,20 20,10 10))//只有一个环的多边形MultiPoint((10 10),(20 20))//多点 MultiLineString多线 多面也类似 WKB 描述几何对象wkb通过序列化的字节对象来描述几何对象 WKT描述空间参考wkt除了可以描述几何对象也可以描述空间对象。对于地理坐标系，比如最常见的WGS84坐标系，wkt是描述如下：12345678GEOGCS[ "GCS_WGS_1984", DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]], PRIMEM["Greenwich",0.0], UNIT["Degree",0.0174532925199433] AUTHORITY["EPSG",4326]] “GEOGCS”表明”[]”中描述的是一个地理坐标系统。该坐标系统名称为”GCS_WGS_1984”;采用的大地基准面为“D_WGS_1984”，该基准面近似椭球体的长轴为6378137.0米、扁率为298.257223563；以格林威治0度经线为起始经线；地图单位为度，该单位的转换因子[2] 为0. 0174532925199433（π/180）；该坐标系统在EPSG[3] 中的编码为“4326”。 对于投影坐标系，WGS84 Web Mercator（Auxiliary Sphere）坐标系统，WKT描述：12345678910111213141516171819PROJCS[ "WGS_1984_Web_Mercator_Auxiliary_Sphere", GEOGCS [ "GCS_WGS_1984", DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]], PRIMEM["Greenwich",0.0], UNIT["Degree",0.0174532925199433] ], PROJECTION["Mercator_Auxiliary_Sphere"], PARAMETER["False_Easting",0.0], PARAMETER["False_Northing",0.0], PARAMETER["Central_Meridian",0.0], PARAMETER["Standard_Parallel_1",0.0], PARAMETER["Auxiliary_Sphere_Type",0.0], UNIT["Meter",1.0], AUTHORITY["EPSG",3857]] “PROJCS”代表这是一个投影坐标系。投影坐标系中必然会包括一个地理坐标系，这里的地理坐标系就是“GCS_WGS_1984”，这个地理坐标系的定义和上面的类似。下面紧跟着的是投影的相关参数，“Mercator_Auxiliary_Sphere”是采用投影的名称，这个投影坐标系以0度经线为中央经线进行投影；坐标系的单位为米（显然，转换因子就为1.0），而该坐标系的EPSG编码为“3857”。 三：GML- 地理标记语言GML是一种基于XML的地理要素描述语言，主要是在不同的软件或系统间交换空间数据。比如WFS要素web服务就使用gml作为输入输出格式。 四：SLD -图层样式描述一个地图不仅包含数据源组成，还需要对数据进行符号化和渲染，sld就是描述地图图层样式的标准，一般用于wms地图web服务。 五：KML主要用于地理数据的可视化，不仅包括地理数据的描述，还包括数据的符号化方式，用户视角的控制等信息。 六：OWS-OGC WEB服务通用标准OWS描述web服务通用的接口规范，包括请求和响应的内容，请求的参数和编码等。 WFS -要素web服务WMS -地图web服务WCS -栅格web服务WMTS -地图切片服务OGD标准介绍.pdf链接：https://pan.baidu.com/s/1abhZc-Wsrk1RbEqGpFb8pw密码：dei6]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见正则表达式校验]]></title>
    <url>%2F2018%2F03%2F20%2F%E5%B8%B8%E8%A7%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[RegExp是什么? RegExp 是正则表达式（Regular expression）的缩写，作用是对字符串执行模式匹配。 通常用于格式验证、正则替换、查找子串等 各种编程语言的正则表达式基本相同，不同的语言可能会有一些细小的差别 推荐一个在线验证的工具https://regex101.com 量词 量词 作用 n+ 匹配任何包含至少一个 n 的字符串。同 {1,} n* 匹配任何包含零个或多个 n 的字符串。同 {0,} n? 匹配任何包含零个或一个 n 的字符串。同 {0,1} n{X} 匹配包含 X 个 n 的序列的字符串。 n{X,Y} 匹配包含 X 至 Y 个 n 的序列的字符串。 n{X,} 匹配包含至少 X 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。注意 /[^a] / 和 /^ [a]/是不一样的，前者是排除的，后者是代表首位。 (?=n) 匹配任何其后紧接指定字符串 n 的字符串。正向预查 (?!n) 匹配任何其后没有紧接指定字符串 n 的字符串。反向预查 RegExp 对象方法test()test() 方法检索字符串中是否存在指定的值。返回值是 true 或 false。1234567891011//判断是不是QQ号//首位不能是0//必须是5-11位数的数字var str = '812634676';var regexp = /^[1-9][0-9]&#123;4,10&#125;$/gim;if (regexp.test(str))&#123; alert('is');&#125;else&#123; alert('no');&#125; exec()exec() 方法检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回 null。1234567var patt1 = new RegExp('e');console.log(patt1.exec('some text'));//OUTPUT:evar patt2 =new RegExp('ee');console.log(patt2.exec('some text'));//OUTPUT:null compile()compile() 既可以改变检索模式，也可以添加或删除第二个参数。12345var patt1=new RegExp("e");document.write(patt1.test("The best things in life are free")); // true// 改变了检索模式patt1.compile("eee");document.write(patt1.test("The best things in life are free")); // false 支持正则表达式的String对象的方法search 检索与正则表达式相匹配的值。123var str = "Visit W3School!";console.log(str.search(/W3School/))// OUTPUT:6 replace替换与正则表达式匹配的子串。123var str = "Visit Microsoft!";console.log(str.replace(/Microsoft/,"W3School"));// OUTPUT:Visit W3School! 1234567891011121314151617181920212223242526// 找重复项最多的字符个数var str = 'g21ss4aeba_ersb43sgnnsssstht6sss60snnsj8resw0_ss'// split : 将字符串转化为数组// sort : 对数组排序，ASCII// join : 将数组转化为字符串var str_new = str.split('').sort.join('');console.log(str_new);//OUTPUT:"0012344668__aabbeeegghjnnnnrrssssssssssssssssttw"var regexp = /(\w)\1+/g;var index = 0;var value = '';str_new.replace(regexp,function($0,$1)&#123; if (index &lt; $0.length)&#123; index = $0.length; value = $1; &#125;&#125;);document.write('重复项最多的字符是：' + value + '，个数是：' + index)// OUTPUT:重复项最多的字符是：s，个数是：16 match找到一个或多个正则表达式的匹配。123var str = "1 plus 2 equal 3"console.log(str.match(/\d+/g))// OUTPUT : 1,2,3 split把字符串分割为字符串数组。123var str = " How are you doing today?"document.write(str.split(/\s+/));// OUTPUT:How,are,you,doing,today? 经验： 检验格式（邮箱格式、IP格式）是否正确，用test() 抓取信息（如所有手机号），用exec()、match() 替换敏感词汇，用replace() 常见的正则表达式校验校验数字的表达式1234567891.数字：^[0-9]*$2.n位的数字： ^\d&#123;n&#125;$3.至少n位的数字： ^\d&#123;n,&#125;$4.m-n位的数字：^\d&#123;m,n&#125;$5.零和非零开头的数字：^(0|[1-9][0-9]*)$6.非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;?)$7.带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$8.正数，负数，和小数：^(\-|\+)?\d+(\.\d+)?$9.非零的正整数：^[1-9]/d*$ 或 ^\+?[1-9][0-9]*$ 校验字符的表达式123451. 汉字:^[\u4e00-\u9fa5]&#123;0,&#125;$2. 英文和数字：^[A-Za-zz-9]+&amp; 或^[A-Za-z0-9]&#123;4,40&#125;$3. 长度为3-20的所有字符：^.&#123;3,20&#125;$4. 由26个英文字母组成的字符串:^[A-Za-z]+&amp;5. 禁止输入含有~的字符：[^~\x22]+ 特殊需求表达式12341.Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$2.域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?3.InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$4.手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-next的魔法糖]]></title>
    <url>%2F2018%2F03%2F07%2Fhexo-next%E7%9A%84%E9%AD%94%E6%B3%95%E7%B3%96%2F</url>
    <content type="text"><![CDATA[文章插入图片 在站点配置文件_config.yml中的post_asset_folder:这个选项设置为true。 在hexo目录下执行 npm install hexo-asset-image --save,这是下载安装一个可以上传本地图片的插件。 运行hexo new &quot;xxx&quot;来生成文章时，在/source/_posts文件夹中生成一个同名的文件夹。 最后在xxx.md中想引入图片时，先把图片复制到这个xxx文件夹中，然后按照markwown的格式引入图片：！[替代文字](xxx/图片名.png)。 hexo-next添加自定义页面 在hexo目录下创建你想要生成的页面 hexo new page &quot;aboutme&quot;。 修改主题配置_config.yml文件中的 menu和menu_icons,如下图其中address-card是在font-Awesome图库图标的名称。 修改主题下的netx/languages/zh-Hans.yml文件中的menu。 运行hexo -s效果图。 设置站点配置文件_config.yml中的skip_render添加aboutme/**,这样就意味着根目录下的source/aboutme文件夹中的内容不会被转化成html。而是直接copy到public文件夹。 &lt;–更多美味糖果–&gt;更新线20180603 必须记录一下白忙活一天的状态了。具体原因是hexo clean会清除public下的所有文件。修改应该source文件下的文件。然后再执行hexo g 生成public。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识与入门Markdown]]></title>
    <url>%2F2018%2F03%2F06%2F%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%85%A5%E9%97%A8Markdown%2F</url>
    <content type="text"><![CDATA[Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。 列表 无序列表使用或者+或者-（注意后面加空格） 有序列表使用数字加. 标题 使用#的个数代表等级数 引用 数据结构 树 二叉树 强调 加粗文本或者这样 斜体 删除怎么没效果 图片与连接 语法格式 图片：![]() ![图片文本（可忽略)](图片地址） 链接：[]() [链接文本]（链接地址） 链接又分为行内，参考，自动 行内链接：文章地址 参考链接：[文章地址][https://ouyangresume.github.io/]，其中url为链接标记，可置于文中任意位置。 自动链接：https://ouyangresume.github.io 图片也有行内和自动。用法差不多 这是图片： 代码 行内代码用`标识这个是行内代码 python manage.py runserver 代码块用123456 ``` javaprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; 分割线 一行中用三个***或者___ 换行 这是一行后面加两个空格加 回车. 脚注 使用[^]来定义脚注。这是一个脚注^1 表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
